TCP/IP四层模型

## 传输层

​		传输层其实是无关路由器端的，是计算机与计算机之间的通信。换句话说是进程与进程之间的网络通信，传输层使用不同的端口来标记不同的网络进程。端口使用16个bit来表示（0~65535）

​		常用的端口有：FTP : 21；HTTP : 80；HTTPS : 443；DNS : 53；TELENT : 23



### UDP协议

​		UDP协议（User Datagram Protocol：用户数据报协议）是一个非常简单的协议，它是**<font color=red>无连接</font>**的协议（无连接是指无须与客户端建立连接，只管发送数据到目的端口），因此它不能保证可靠的交付数据，无法保证数据在网络中是否丢失

​		UDP没有拥塞控制，而且首部开销很少。UDP是面向数据报文传输的（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）

#### UDP首部格式

![UDP首部格式](images\0.UDP首部格式.jpg)

​		首部字段只有 8 个字节（64bit），包括源端口、目的端口、UDP长度、UDP检验和。12 字节的伪首部是为了计算检验和临时添加的



### TCP协议

​		TCP（Transmission Control Protocol：传输控制协议）是面向连接的协议，且是点对点的通信模式；并且它提供了可靠的传输服务。TCP协议提供全双工的通信，它是面向字节流的传输协议



#### TCP协议详解

![TCP首部格式](images\0.TCP首部格式.png)

首部内容详解

- <font color=blue>**序号：**</font>用于对字节流进行编号（可表示的长度是：0~2^32-1）

  > ​		例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401

- <font color=blue>**确认号：**</font>期望收到的下一个报文段的序号

  > ​		例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，<font color=red>**B 发送给 A 的确认报文**段中确认号就为 701</font>

- <font color=blue>**数据偏移：**</font>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度

- <font color=blue>**TCP标志：**</font>也就是图中URG，SYN，FIN，ACK；下面详解

- <font color=blue>**窗口** ：</font>窗口值作为接收方让发送方设置其发送数据量的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的

- <font color=blue>**紧急指针：**</font>紧急数据，当TCP标志是URG=1时，指定紧急数据在报文中的位置



#### TCP标志

TCP标志占6位，表示不同的含义

- <font color=blue>URG：</font>Urgent，紧急位；当URG=1时表示紧急数据
- <font color=blue>**ACK：**</font>Acknowledgement，确认位；当ACK=1时，确认号才生效
- <font color=blue>PSH：</font>Psuh，推送位；PSH=1表示尽快把数据交付给应用层
- <font color=blue>RST：</font>Reset，重置位；RST=1表示重新建立连接
- <font color=blue>**SYN：**</font>Synchronization，同步位；SYN=1时表示连接请求报文
- <font color=blue>**FIN：**</font>Finish，终止位；FIN=1时表示释放连接



### *TCP三次握手

![TCP三次握手](images\0.TCP三次握手.png)

TCP标志：SYN（同步位），ACK（确认位）

seq是TCP首部的序号，ack是TCP首部的确认号



1. 首先 接收方 处于 LISTEN（监听）状态，等待客户的连接请求
2. 发送方 向 接收方 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 seq=x
3. 接收方 收到连接请求报文，如果同意建立连接，则向 发送方 发送连接确认报文，SYN=1，ACK=1，确认号为 ack=x+1，同时也选择一个初始的序号 seq=y
4. 发送方 收到 接收方 的连接确认报文后，还要向 接收方 发出确认，确认号为 ack=y+1，序号为 seq=x+1
5. 接收方 收到 发送方 的确认后，连接建立；然后进行数据传输



#### 三次握手的原因

为什么需要第三次握手？

​		<font color=red>因为有第三次握手可以**防止失效的连接请求到达服务器**，让服务器错误打开连接</font>

​		客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。<u>**客户端等待一个超时重传时间之后，就会重新请求连接**</u>。但是这个滞留的连接请求最后还是会到达服务器，<font color=blue>如果不进行三次握手，那么服务器就会打开两个连接</font>。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接



### *TCP四次挥手

![TCP四次挥手](images\0.TCP四次挥手.png)

TCP标志：FIN（终止位）



1. 发送方 发送连接释放报文，FIN=1，seq=u
2. 接收方 收到之后发出确认，ACK=1，seq=v，ack=u+1；此时 TCP 属于半关闭状态，<font color=red>接收方 能向 发送方 发送数据但是 发送方 不能向 接收方 发送数据</font>
3. 当 **接收方** 不再需要连接时，**发送连接释放报文**，FIN=1，ACK=1，seq=w，ack=u+1
4. 发送方 收到后发出确认，ACK=1，seq=u+1，ack=w+1，进入 TIME-WAIT （等待计时器）状态，等待 2 MSL（<font color=red>最大报文存活时间</font>）后释放连接
5. 接收方 收到 发送方 的确认后释放连接



注意：接收方收到发送方的第四次挥手时就已经关闭的连接了，而发送方会等待2MSL后再关闭连接



#### 四次挥手的原因

​		客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT （关闭等待）状态。这个状态是<font color=red>为了让服务器端发送还未传送完毕的数据</font>，传送完毕之后，服务器会发送 FIN 连接释放报文



#### 为什么要等待2MSL

​		客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- <font color=red>确保最后一个确认报文能够到达</font>。如果 接收方 没收到 发送方 发送来的确认报文，那么就会重新发送连接释放请求报文，发送方 等待一段时间就是为了处理这种情况的发生
- 等待一段时间是为了<font color=red>让本连接持续时间内所产生的所有报文都从网络中消失（过期）</font>，使得下一个新的连接不会出现旧的连接请求报文



### TCP可靠传输

#### 停止等待协议

​		一个报文的传输，会从发送方发送到接收方，等待接收方的确认后再发送下一个数据报文。在出现差错的时候，如 接收方发送的确认帧丢失 或者 发送的数据报文丢失。这个时候<font color=red>TCP 使用**超时重传**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段</font>

​		如果接收方的确认消息在很久之后才到达发送方，此时已经将之前的消息重传了；对于这种情况，TCP会每发送一个消息都会设置一个定时器（超时定时器），确认消息超时之后就会重传消息

​		停止等待协议很简单，但是对信道的利用率不高；因为每次都需要等待，而且只能每次发送一个消息



#### 连续ARQ协议（滑动窗口）

​		ARQ（Automatic Repeat reQuest：自动重传请求）；TCP的可靠传输基于连续ARQ协议，<font color=red>滑动窗口是以**字节**为单位的</font>



待补充。。。

### TCP流量控制

​		流量控制是为了<font color=red> 控制发送方发送速率</font>，保证接收方来得及接收。

​		接收方发送的确认报文中的**窗口字段**可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据（也就是使用滑动窗口实现的）

![TCP流量控制](images\0.TCP流量控制.png)

​		接收方通过窗口大小去控制发送方的发送速率，来对流量进行控制。这里有可能最后的 rwnd=1000 传输的时候丢失了，这个时候会导致接收方一直等待发送方的数据，而发送方也一直等待接收方的控制消息

​		这个时候就有一个坚持定时器去解决这样的问题。当接收到窗口为0的消息，发送方就启动坚持定时器，每隔一段时间就发送一个窗口探测报文给接收方



### TCP拥塞控制

<font color=red>网络拥塞是指**报文超时**</font>

- 流量控制是考虑点对点的通信量的控制

- 拥塞控制是**考虑整个网络，是全局性的考虑**

  ​		如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而<font color=blue>拥塞控制是为了降低整个网络的拥塞程度</font>



TCP 主要通过四个算法来进行拥塞控制：慢启动、拥塞避免、快重传、快恢复

​		发送方需要维护一个叫做**拥塞窗口（cwnd）**的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口

#### 慢启动

​		发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...（加倍是2的指数形式增长）

​		注意到慢启动每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。索引设置一个慢启动的阈值 ssthresh，达到阈值就不再指数增长了

#### 拥塞避免

​		当慢启动的窗口大小 cwnd >= ssthresh （慢启动阈值）时，那么就进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始