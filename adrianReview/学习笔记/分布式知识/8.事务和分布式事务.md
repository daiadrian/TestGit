事务和分布式事务

## 数据库事务

​	事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务

> ​	当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行
>
> ​	但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。
>
> ​	这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作

​	事务作为单个逻辑单元执行的一组操作，要么全部执行成功，要么全部失败。在关系型数据库中，一个事务可以是一条SQL也可以是一组SQL

​	事务具有4个特性：原子性、一致性、隔离性和持久性

1. 原子性（atomicity）：一个事务包含的操作是不可分割的，要么全部执行成功，要么全部失败回滚
2. 一致性（consistency）：事务必须是使数据库从一个一致性状态到另一个一致性的状态
3. 隔离性（isolation）：一个事务的执行不能被其他事务干扰；即一个事务内的操作及其使用的数据对并发的其他事务操作是隔离的，互不干扰的
4. 持久性（durability）：一个事务一旦提交，那么它对数据库的改变是永久的



## 分布式事务

了解分布式事务之前，先假设如果没有分布式事务会出现的问题：

> ​	假如没有分布式事务，在微服务的场景下（各个服务有自己独立的数据库），当一个购物的业务逻辑操作执行时，会分别调用库存服务去将该商品的库存减一（库存服务使用库存的DB），调用订单服务去生成这个用户的商品订单（订单服务使用订单服务的DB）
>
> ​	正常的情况下是，库存减一操作和生成订单的操作都是成功的，那么数据就保持一致性了。但是，当库存减一成功后，订单生成出现异常，插入失败了；那么这个时候数据就满足一致性了
>
> ​	这种情况下要保证数据的一致性就要依靠分布式事务了。所以单数据源的一致性依靠单机事务来保证，多数据源的情况就要依赖分布式事务了

​	分布式事务就是用于在分布式系统中保证不同节点之间的数据一致性。简单的说，就是一次大操作由不同小操作组成，这些小操作**分布在不同服务器上，分布式事务需要保证这些小操作要么全部成功，要么全部失败**



### 分布式事务实现方案

#### XA方案

​		 XA 方案即：两阶段提交

​		有一个**事务管理器**的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务

​		这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景

> ​		一般来说**某个系统内部如果出现跨多个库**的这么一个操作，是**不合规**的
>
> ​		例如：现在的微服务系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求**每个服务只能操作自己对应的一个数据库**。如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，如果被随便交叉胡乱访问，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。如果你要操作别人的服务的库，你必须是通过**调用别的服务的接口**来实现，绝对不允许交叉访问别人的数据库



#### TCC方案

​		TCC 的全称是：`Try`、`Confirm`、`Cancel`。

- Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行**锁定或者预留**
- Confirm 阶段：这个阶段说的是在各个服务中**执行实际的操作**
- Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要**进行补偿**，就是执行已经执行成功的业务逻辑的回滚操作（把那些执行成功的回滚）



​		这种方案说实话几乎很少人使用，但是也有使用的场景。因为这个**事务回滚**实际上是**严重依赖于写代码来回滚和补偿**了，会造成补偿代码异常巨大

> ​		TCC的使用的场景一般来说跟**钱**相关的，**支付**、**交易**相关的场景；严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。而且最好是各个业务执行的时间都比较短



#### 本地消息表

​		本地消息表的方案实现思路：

1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着 A 系统将这个消息发送到 MQ 中去；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样**保证不会重复处理消息**；
4. B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
5. 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；
6. 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。



​		这个方案说实话最大的问题就在于**严重依赖于数据库的消息表来管理事务**，在高并发场景下的性能和吞吐量很一般，所以一般很少用



#### 可靠消息最终一致性方案

