分布式系统生成唯一ID

推荐文章： [美团分布式ID生成系统文章](https://tech.meituan.com/2017/04/21/mt-leaf.html)

## 常见的生成ID的方案

### 数据库自增长

​	最常见的方式。利用数据库，全数据库唯一

1. 优点：
   - 简单，代码方便，性能可以接受
   - 对分页和排序结果有很大的帮助
2. 缺点：
   - 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理
   - 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险
   - 在性能达不到要求的情况下，比较难于扩展
   - 分库分表会相当麻烦
3. 分布式下的自增长：

​	在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。（Master1 生成的是 1,4,7,10，Master2生成的是2,5,8,11 ，Master3生成的是 3,6,9,12）但是这样在还会存在一些问题：

- 系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。<font color=red>扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现</font>



#### 针对数值增长的变种优化

````java
public class keyNode{
    public Integer currentIndex;
    public Integer limit;//limit = currentIndex + n
}
````

​		主键依旧是数值类型，但不以自增长作为数据库ID生成。

​		可以建立一个表存放tableName和该表的Last_ID值（即当前的ID增长到的值）。

​		当应用启动或者重启的时候，去获取数据库这个表对应tableName的数据，然后将数据值 +n （即步长为n）操作，然后写回去数据库（一定要+n操作后先写入该表），将值赋值到keyNode存放到Reids缓存或者本地即可（存放到本地也不会有冲突问题，因为要先加写入表中再正式赋值，所以不同机器上的应用不会重复），然后当currentIndex >= limit的时候，去数据库获取最新的last_id的值后继续上述操作

​		虽然这样当重启的时候会浪费掉一些ID值，但是也是相当的方便对ID的增长式的实现



### UUID

可以利用数据库也可以利用程序生成，一般来说全球唯一

1. 优点
   - 简单，代码方便
   - 生成ID性能好，一般不会有性能问题
   - 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对
2. 缺点
   - **没有排序，无法保证趋势递增**
   - UUID往往是使用字符串存储，**查询的效率比较低**
   - 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题
   - 传输数据量大和不可读



#### 顺序UUID

​		按照时间得到的有顺序的UUID（maven artifactId：java-uuid-generator）



### SnowFlake算法（Twitter）

​		snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。

​		其核心思想是：

- 第一位是一个符号位，永远是0
- 然后使用41bit作为毫秒数
- 10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID）
- 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）

​	这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是理论上snowflake方案的QPS约为409.6w/s，完全能满足一般业务的需求

> 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
>
> - 1位标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以为0； 
> - 41位时间戳部分，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年； 
> - 10位节点部分，Twitter实现中使用前5位作为数据中心标识，后5位作为机器标识，可以部署1024个节点； 
>
> - 12位序列号部分，支持同一毫秒内同一个节点可以生成4096（1 << 12）个ID；

1. 优点
   - 不依赖于数据库，灵活方便，且性能优于数据库
   - ID按照时间在单机上是递增的；毫秒数在高位，自增序列在低位，整个ID都是趋势递增的
2. 缺点
   - 在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况



### Zookeeper生成唯一ID

​		zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号

​		很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁

​		在高并发的分布式环境下，写入的QPS达到1000+以上的时候ZK很可能会扛不住，而且在ZK集群数据同步中，需要**半数的机子成功插入数据才算是同步成功**，那么性能瓶颈会被无限的放大



### MongoDB的ObjectId

​		MongoDB的ObjectId和snowflake算法类似。它设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。MongoDB 从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求。使其在分片环境中要容易生成得多

​		ObjectId	前4 个字节是从标准纪元开始的时间戳，单位为秒。

> 由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。 

​		接下来的3 字节是所在主机的唯一标识符。

> 通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。 为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的

​		接下来的两字节来自产生ObjectId 的进程标识符（PID）。 前9 字节提供了秒级别的唯一性。保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId	



