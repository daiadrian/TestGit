## 1.权限管理概念

在权限管理的概念中，有两个非常重要的名词：

- <font color=red>**认证：**</font>通过用户名和密码成功登陆系统后，让系统得到当前用户的角色身份
- <font color=red>**授权：**</font>系统根据当前用户的角色，给其授予对应可以操作的权限资源

> 权限系统的三个主要对象：
>
> 1. **<font color=red>用户：</font>**主要包含用户名，密码和当前用户的角色信息，可实现认证操作
> 2. **<font color=red>角色：</font>**主要包含角色名称，角色描述和当前角色拥有的权限信息，可实现授权操作
> 3. **<font color=red>权限：</font>**权限也可以称为菜单，主要包含当前权限名称，url地址等信息，可实现动态展示菜单
>
> > 注：这三个对象中，用户与角色是多对多的关系，角色与权限是多对多的关系，用户与权限没有直接关系，二者是通过角色来建立关联关系的



## 2.核心组件

### 2.1 SecurityContextHolder身份信息的容器

 		`SecurityContextHolder` 用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限，这些都被保存在 SecurityContextHolder 中

​		`SecurityContextHolder`默认使用 `ThreadLocal` 策略来存储认证信息（这是一种与线程绑定的策略）。Spring Security 在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息

**获取当前用户的信息：**

```java
Object principal = SecurityContextHolder
                        .getContext()
                        .getAuthentication()
                        .getPrincipal();

if (principal instanceof UserDetails) {
	String username = ((UserDetails) principal).getUsername();
} else {
	String username = principal.toString();
}
```

 		`getAuthentication()` 返回了认证信息，再次 `getPrincipal()` 返回了身份信息，UserDetails 便是 Spring 对身份信息封装的一个接口



### 2.2 Authentication身份信息的抽象

Authentication（译：认证方式）；Principal（译：主要的，负责人）

```java
public interface Authentication extends Principal, Serializable {

	Collection<? extends GrantedAuthority> getAuthorities();

	Object getCredentials();

    /**
      *
      */
	Object getDetails();

    /**
      *
      */
	Object getPrincipal();

    /**
      *
      */
	boolean isAuthenticated();

    /**
      *
      */
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}
```



​		 Authentication 在 spring security 中是最高级别的 身份 / 认证的抽象；可以从这个接口中得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息

#### 接口方法解析：

1.  `getAuthorities()`，权限信息列表
   - 默认是 GrantedAuthority 接口的一些实现类，通常是代表权限信息的一系列字符串 
2. `getCredentials()` ，密码信息
   - 用户输入的密码字符串，在<font color=blue>认证过后通常会被移除</font>，用于保障安全 
3.  `getDetails()`，细节信息
   - web 应用中的实现接口通常为 WebAuthenticationDetails，<font color=blue>它记录了访问者的 ip 地址和 sessionId 的值 </font>
4.  `getPrincipal()`，<font color=red>**身份信息**，大部分情况下返回的是 UserDetails 接口的实现类</font>



### 2.3AuthenticationManager身份认证器 

 		**AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点**

> ​		因为在实际需求中，我们可能会允许用户使用用户名 + 密码登录，同时允许用户使用邮箱 + 密码，手机号码 + 密码登录，甚至可能允许用户使用指纹登录，所以说 AuthenticationManager 一般不直接认证

​		AuthenticationManager 接口的 **常用实现类 ProviderManager** 内部会维护一个 `List` 列表，存放多种认证方式，实际上这是委托者模式的应用

​		也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式则对应了三个 AuthenticationProvider。<font color=green>在默认策略下，只需要通过一个 AuthenticationProvider 的认证，即可被认为是登录成功 </font>

#### 认证源码简单流程

```java
public class ProviderManager implements AuthenticationManager, MessageSourceAware,
		InitializingBean {
    // 维护一个 AuthenticationProvider 列表
    private List<AuthenticationProvider> providers = Collections.emptyList();
          
    public Authentication authenticate(Authentication authentication)
          throws AuthenticationException {
       Class<? extends Authentication> toTest = authentication.getClass();
       AuthenticationException lastException = null;
       Authentication result = null;

       // 多种认证方式 依次认证
       for (AuthenticationProvider provider : getProviders()) {
          if (!provider.supports(toTest)) {
             continue;
          }
          try {
             result = provider.authenticate(authentication);
             if (result != null) {
                copyDetails(authentication, result);
                break;
             }
          }
          ...
          catch (AuthenticationException e) {
             lastException = e;
          }
       }
       // 如果有 Authentication 信息，则直接返回
       if (result != null) {
			if (eraseCredentialsAfterAuthentication
					&& (result instanceof CredentialsContainer)) {
              	 // 移除密码
				((CredentialsContainer) result).eraseCredentials();
			}
             // 发布登录成功事件
			eventPublisher.publishAuthenticationSuccess(result);
			return result;
	   }
	   ...
       // 执行到此，说明没有认证成功，包装异常信息
       if (lastException == null) {
          lastException = new ProviderNotFoundException(messages.getMessage(
                "ProviderManager.providerNotFound",
                new Object[] { toTest.getName() },
                "No AuthenticationProvider found for {0}"));
       }
       prepareException(lastException, authentication);
       throw lastException;
    }
}
```

- `ProviderManager` 中的 List，会依照次序去认证
  - 认证成功则立即返回
  - 若认证失败则返回 null，下一个 AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 `ProviderManager` 会抛出一个 ProviderNotFoundException 异常



#### AuthenticationProvider 

 		AuthenticationProvider 最最最常用的一个实现便是 DaoAuthenticationProvider 

在 Spring Security 中：

- 提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken
- 根据用户名加载用户的任务则是交给了 UserDetailsService，在 DaoAuthenticationProvider 中，对应的方法便是 retrieveUser，虽然有两个参数，但是 retrieveUser 只有第一个参数起主要作用，返回一个 UserDetails
- 还需要完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对，这便是交给 additionalAuthenticationChecks 方法完成的，如果这个 void 方法没有抛异常，则认为比对成功



### 2.4 UserDetails和UserDetailsService

 		UserDetails 这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展 

​		 UserDetailsService 只负责从特定的地方（通常是数据库）加载用户信息。 UserDetailsService 常见的实现类有 JdbcDaoImpl，InMemoryUserDetailsManager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现 UserDetailsService



**<font size=4px>UserDetail和Authentication区别</font>**

-  Authentication 的 `getCredentials()` 与 UserDetails 中的 `getPassword()` 需要被区分对待
  - Authentication 是用户提交的密码凭证
  - UserDetails 是用户正确的密码，认证器其实就是对这两者的比对
-  Authentication 中的 `getAuthorities()` 实际是由 UserDetails 的 `getAuthorities()` 传递而形成的 
-  Authentication 接口中的 `getUserDetails()` 方法的 UserDetails 用户详细信息是经过 AuthenticationProvider 之后被设置进来的





## 3.核心过滤器SpringSecurityFilterChain 

​		SpringSecurityFilterChain 是 SpringSecurity 的核心过滤器，是整个认证的入口。但是负责拦截请求的是 DelegatingFilterProxy 这个代理类

<font size=4px>**拦截请求的流程：**</font>

1. DelegatingFilterProxy 这个代理类会通过 beanName 为 springSecurityFilterChain 得到一个过滤器，这个过滤器是 FilterChainProxy ，然后执行这个过滤器
2. FilterChainProxy 过滤器会遍历封装要执行的过滤器链，然后加载过滤器链
   - 这里的过滤器链就是默认常用的 15 个过滤器



### 3.1常用过滤器

执行顺序从上往下

1. ***<font color=blue>SecurityContextPersistenceFilter</font>***
   - 使用 SecurityContextRepository 在 Session 中保存或更新一个 SecurityContext，并将 SecurityContext 给以后的过滤器使用，来为后续拦截器建立所需的上下文；请求结束后会清空SecurityContext
   - SecurityContext 中存储了当前用户的认证以及权限信息，可以说是安全上下文信息
2. ***WebAsyncManagerIntegrationFilter***
   - 用于集成 SecurityContext 到 Spring 异步执行机制中的 WebAsyncManager
3. ***HeaderWriterFilter***
   - 向请求的Header中添加相应的信息： 比如 X-Frame-Options，X-XSS-Protection*，X-Content-Type-Options
4. ***<font color=blue>CsrfFilter</font>***
   - csrf又称跨域请求伪造，SpringSecurity 会对**所有 POST 请求**验证是否包含系统生成的 csrf 的 Token 信息，如果不包含，则报错。起到防止csrf攻击的效果。
5. ***LogoutFilter***
   - 匹配URL为 `/logout` 的请求，实现用户退出，清除认证信息
6. ***<font color=blue>UsernamePasswordAuthenticationFilter</font>***
   - 认证操作全靠这个过滤器，默认匹配URL为 `/login` 且必须为 POST 请求
7. ***DefaultLoginPageGeneratingFilter***
   - 如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面
8. ***DefaultLogoutPageGeneratingFilter***
   - 由此过滤器可以生成一个默认的退出登录页面
9. ***BasicAuthenticationFilter***
   - 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息
10. ***RequestCacheAwareFilter***
    - 通过HttpSessionRequestCache内部维护了一个RequestCache，用于缓存 HttpServletRequest
11. ***SecurityContextHolderAwareRequestFilter***
    - 针对ServletRequest进行了一次包装，使得 Request 具有更加丰富的API
12. ***<font color=blue>AnonymousAuthenticationFilter</font>***
    - 当SecurityContextHolder中认证信息为空，则会创建一个***匿名用户*** 存入到SecurityContextHolder中
    - SpringSecurity为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份
13. ***SessionManagementFilter***
    - SecurityContextRepository 限制同一用户开启多个会话的数量
14. ***<font color=blue>ExceptionTranslationFilter</font>***
    - 异常转换过滤器，用来转换整个链路中出现的异常
    -  这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理 
15. ***<font color=blue>FilterSecurityInterceptor</font>***
    - 获取所配置资源访问的授权信息
    - 然后根据 SecurityContextHolder 中存储的用户信息来决定其是否有权限



### 3.2SecurityContextPersistenceFilter

SecurityContextPersistenceFilter 的两个主要作用便是：

① 请求来临时，创建 `SecurityContext` 安全上下文信息

②请求结束时清空 `SecurityContextHolder`

​		微服务的一个设计理念需要实现服务通信的无状态，而 http 协议中的无状态意味着不允许存在 session，这可以通过 `setAllowSessionCreation(false)` 实现，但是这并不意味着 SecurityContextPersistenceFilter 变得无用，因为它还需要负责清除用户信息

​		在 Spring Security 中，虽然安全上下文信息被存储于 Session 中，但在实际使用中不应该直接操作 Session，而应当使用 ***SecurityContextHolder*** 

```java
public class SecurityContextPersistenceFilter extends GenericFilterBean {

   static final String FILTER_APPLIED = "__spring_security_scpf_applied";
   // 安全上下文存储的仓库，其实是HttpSessionSecurityContextRepository
   private SecurityContextRepository repo;
  
   public SecurityContextPersistenceFilter() {
      // HttpSessionSecurityContextRepository 是 SecurityContextRepository 接口的一个实现类
      // 使用 HttpSession 来存储 SecurityContext
      this(new HttpSessionSecurityContextRepository());
   }

   public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
         throws IOException, ServletException {
      HttpServletRequest request = (HttpServletRequest) req;
      HttpServletResponse response = (HttpServletResponse) res;

      if (request.getAttribute(FILTER_APPLIED) != null) {
         chain.doFilter(request, response);
         return;
      }
      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);
      // 包装 request，response
      HttpRequestResponseHolder holder = new HttpRequestResponseHolder(request,
            response);
      // 从 Session 中获取安全上下文信息
      SecurityContext contextBeforeChainExecution = repo.loadContext(holder);
      try {
         // 请求开始时，设置安全上下文信息，这样就避免了用户直接从 Session 中获取安全上下文信息
         SecurityContextHolder.setContext(contextBeforeChainExecution);
         chain.doFilter(holder.getRequest(), holder.getResponse());
      }
      finally {
         // 请求结束后，清空安全上下文信息
         SecurityContext contextAfterChainExecution = SecurityContextHolder
               .getContext();
         SecurityContextHolder.clearContext();
         repo.saveContext(contextAfterChainExecution, holder.getRequest(),
               holder.getResponse());
         request.removeAttribute(FILTER_APPLIED);
         if (debug) {
            logger.debug("...");
         }
      }
   }
}
```



```java
public class HttpSessionSecurityContextRepository implements SecurityContextRepository {
   // 'SPRING_SECURITY_CONTEXT' 是安全上下文默认存储在 Session 中的键值
   public static final String SPRING_SECURITY_CONTEXT_KEY = "SPRING_SECURITY_CONTEXT";
   ...
   private final Object contextObject = SecurityContextHolder.createEmptyContext();
   private boolean allowSessionCreation = true;
   private boolean disableUrlRewriting = false;
   private String springSecurityContextKey = SPRING_SECURITY_CONTEXT_KEY;

   private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();

   // 从当前 request 中取出安全上下文，如果 session 为空，则会返回一个新的安全上下文
   public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
      HttpServletRequest request = requestResponseHolder.getRequest();
      HttpServletResponse response = requestResponseHolder.getResponse();
      HttpSession httpSession = request.getSession(false);
      SecurityContext context = readSecurityContextFromSession(httpSession);
      if (context == null) {
         context = generateNewContext();
      }
      ...
      return context;
   }

   ...

   public boolean containsContext(HttpServletRequest request) {
      HttpSession session = request.getSession(false);
      if (session == null) {
         return false;
      }
      return session.getAttribute(springSecurityContextKey) != null;
   }

   private SecurityContext readSecurityContextFromSession(HttpSession httpSession) {
      if (httpSession == null) {
         return null;
      }
      ...
      // Session 存在的情况下，尝试获取其中的 SecurityContext
      Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);
      if (contextFromSession == null) {
         return null;
      }
      ...
      return (SecurityContext) contextFromSession;
   }

   // 初次请求时创建一个新的 SecurityContext 实例
   protected SecurityContext generateNewContext() {
      return SecurityContextHolder.createEmptyContext();
   }

}
```

