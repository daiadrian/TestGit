springboot 2.x笔记

## 常用注解

### Java中的注解

Java注解，在注解上的内建注解的作用

1. @Retention

   > (SOURCE,CLASS,RUNTIME) 注解的保留策略
   >
   > - SOURCE：注解仅存在于源码中，在class字节码文件中不包含
   > - CLASS：默认的保留策略，注解会在class字节码文件中存在，但					运行时无法获得
   > - RUNTIME：注解会在class字节码文件中存在，在运行时可以通过					反射获取到

2. @Target

   > 注解的作用目标
   >
   > - TYPE：接口、类、枚举、注解
   >
   > - FIELD：属性、枚举的常量
   > - METHOD：方法
   > - PARAMETER：方法上的参数(形参)
   > - CONSTRUCTOR：构造函数
   > - LOCAL_VARIABLE：局部变量
   > - ANNOTATION_TYPE：注解
   > - PACKAGE：包

3. @Documented：注解包含在javadoc中

4. @Inherited：注解可以被继承

5. @Constraint：注解标注表明指定了一个用于验证的类

6. @Deprecated：说明被标记的元素不应该再度使用。这个注解会让编译器产生警告消息。可以使用到方法，类和域上。相应的解释和原因，包括另一个可取代的方法应该同时和这个注解使用

7. @SuppressWarnings：说明编译器不会针对指定的一个或多个原因产生警告

8. @Override：向编译器说明被注解元素是重写的父类的一个元素。在重写父类元素的时候此注解并非强制性的，不过可以在重写错误时帮助编译器产生错误以提醒我们。比如子类方法的参数和父类不匹配，或返回值类型不同

```java
@Documented
@Target({ANNOTATION_TYPE, METHOD, CONSTRUCTOR, FIELD})
@Retention(RUNTIME)
@Constraint(validatedBy = IsMobileValidator.class)
public @interface IsMobile {
    boolean required() default false;
    String message() default "手机号码格式出错";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

}
```

### @ComponentScan

- value：指定要扫描的包

- includeFilters：指定扫描的时候只需要包含哪些组件

- excludeFilters：指定扫描的时候按照什么规则排除那些组件

  > FilterType.**ANNOTATION**：按照注解
  > FilterType.**ASSIGNABLE_TYPE**：按照给定的类型
  > FilterType.**ASPECTJ**：使用ASPECTJ表达式
  > FilterType.**REGEX**：使用正则指定
  > FilterType.**CUSTOM**：使用自定义规则
  >
  > ````java
  > @ComponentScan(value="com.csdn.dh",includeFilters = {		@Filter(type=FilterType.ANNOTATION,classes{Controller.class}), @Filter(type=FilterType.ASSIGNABLE_TYPE,classes={UserService.class}),
  > @Filter(type=FilterType.CUSTOM,classes={MyTypeFilter.class})}
  > ````
  >
  > 自定义规则：
  >
  > ````java
  > public class MyTypeFilter implements TypeFilter {
  > 	/**
  > 	 * metadataReader：读取到的当前正在扫描的类的信息
  > 	 * metadataReaderFactory:可以获取到其他任何类信息的
  > 	 */
  > 	@Override
  > 	public boolean match(MetadataReader metadataReader,
  > 			MetadataReaderFactory metadataReaderFactory) throws IOException {
  > 		//获取当前类注解的信息
  > 		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
  > 		//获取当前正在扫描的类的类信息
  > 		ClassMetadata classMetadata = metadataReader.getClassMetadata();
  > 		//获取当前类资源（类的路径）
  > 		Resource resource = metadataReader.getResource();
  > 		
  > 		//className是全类名  com.csdn.dh.pojo.User
  > 		String className = classMetadata.getClassName();
  > 		System.out.println(className);
  > 		if (className.contains("Pojo")) 
  > 			return true;
  > 		return false;
  > 	}
  > }
  > ````

- useDefaultFilters：这个属性是指是否自动扫描带有@Component、@Repository、@Service、@Controller注解的类，默认是true

### @Scope

@Scpoe：用于调整作用域，默认是singleton

- prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象
- singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿
- request：同一次请求创建一个实例
- session：同一个session创建一个实例

### @Conditional

@Conditional：按照一定的条件进行判断，给容器中注册满足条件的Bean

> ````java
> public class MyCondition implements Condition {
> 	/**
> 	 * ConditionContext：判断条件能使用的上下文（环境）
> 	 * AnnotatedTypeMetadata：注释信息
> 	 */
> 	@Override
> 	public boolean matches(ConditionContext context,AnnotatedTypeMetadata metadata) {
> 		//获取到容器使用的beanfactory
> 		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
> 		//获取类加载器
> 		ClassLoader classLoader = context.getClassLoader();
> 		//获取当前环境信息
> 		Environment environment = context.getEnvironment();
> 		//获取到Bean定义的注册类
> 		BeanDefinitionRegistry registry = context.getRegistry();
> 		return true;
> 	}
> }
> ````

### @Import

@Import：快速给容器中导入一个组件

> ````java
> public class MyImportSelector implements ImportSelector {
> 	//返回的String数组就是到导入到容器中的组件全类名
> 	//AnnotationMetadata:当前标注@Import注解的类的所有注解信息
> 	@Override
> 	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
> 		//方法不要返回null值,否则会报空指针异常(读者可以自行debug看一下原因)
> 		return new String[]{"com.csdn.dh.pojo.User"};
> 	}
> }
> ````
>
> ````java
> public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
> 	/**
> 	 * AnnotationMetadata：当前类的注解信息
> 	 * BeanDefinitionRegistry:BeanDefinition注册类；
> 	 * 		把所有需要添加到容器中的bean；调用BeanDefinitionRegistry.registerBeanDefinition手工注册进来
> 	 */
> 	@Override
> 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
> 		//指定Bean定义信息；（Bean的类型）
> 		RootBeanDefinition beanDefinition = new RootBeanDefinition(User.class);
> 		//注册一个Bean，指定bean名
> 		registry.registerBeanDefinition("user", beanDefinition);
> 		}
> 	}
> }
> ````
>

### @DependsOn

​	该注解用于声明当前bean依赖于另外一个bean。所依赖的bean会被容器确保在当前bean实例化之前被实例化。举例来讲，如果容器通过@DependsOn注解方式定义了bean plant依赖于bean water,那么容器在会确保bean water的实例在实例化bean plant之前完成。

​	一般用在一个bean没有通过属性或者构造函数参数显式依赖另外一个bean，但实际上会使用到那个bean或者那个bean产生的某些结果的情况。

1. 直接或者间接标注在带有@Component注解的类上面;
   使用@DependsOn注解到类层面仅仅在使用component scanning方式时才有效;如果带有@DependsOn注解的类通过XML方式使用，该注解会被忽略，<bean depends-on="..."/>这种方式会生效;
2. 直接或者间接标注在带有@Bean 注解的方法上面;

### @PostConstruct

​	@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且**只会被服务器执行一次**。

​	PostConstruct在构造函数之后执行，init（）方法之前执行。通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：Constructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)

​	如果想在生成对象时候完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么就无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。



## 常用组件

### 过滤器

````java
@Component
public class MyInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //调用Controller之前被调用
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
        //调用Controller之后被调用，但是在渲染View页面之前
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
        //DispatcherServlet 渲染了对应的视图之后执行,主要作用是用于进行资源清理工作的
    }
}
````

````java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	
	@Autowired
	MyInterceptor myInterceptor;

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(myInterceptor).addPathPatterns("/**");
	}
}
````

### 全局异常处理器

````java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    //处理的异常是BindException
    @ExceptionHandler(value = BindException.class)
    public String exceptionHandler(HttpServletRequest request, Exception e) {
        BindException ex = (BindException) e;
        List<ObjectError> errors = ex.getAllErrors();
        return errors.get(0).getDefaultMessage();
    }

}
````

### 自定义参数解析HandlerMethodArgumentResolver

````java
@Service
public class UserArgumentResolver implements HandlerMethodArgumentResolver {

	@Autowired
	Jedis jedis;
	
    /**
	 * 需要实现的方法之一,当这个方法返回true的时候才会执行resolveArgument方法
	 * 这里指的是判断方法参数中是否含有User参数
	 */
	public boolean supportsParameter(MethodParameter parameter) {
		Class<?> clazz = parameter.getParameterType();
		return clazz==User.class;
	}

    /**
	 * 从cookie中获取token,利用token去获取redis中的数据
	 * 然后将获取到的数据绑定到该方法上
	 */
	public Object resolveArgument(MethodParameter parameter, 
                                  ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, 
                                  WebDataBinderFactory binderFactory) throws Exception {
		HttpServletRequest request = 
            webRequest.getNativeRequest(HttpServletRequest.class);
		String cookieToken = getCookieValue(request, "UserArgumentResolver");
		if(StringUtils.isEmpty(cookieToken)) {
			return null;
		}
		String str = jedis.get(cookieToken);
		User user = JSON.parseObject(str, User.class);
		return user;
	}

	private String getCookieValue(HttpServletRequest request, String cookiName) {
		Cookie[]  cookies = request.getCookies();
		for(Cookie cookie : cookies) {
			if(cookie.getName().equals(cookiName)) {
				return cookie.getValue();
			}
		}
		return null;
	}

}
````

````java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	
	@Autowired
	UserArgumentResolver userArgumentResolver;
	
	@Override
	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
		argumentResolvers.add(userArgumentResolver);
	}

}
````

### Aware接口（获取spring容器）

| 类名                           | 作用                                           |
| ------------------------------ | ---------------------------------------------- |
| BeanNameAware                  | 获得到容器中Bean 的名称                        |
| BeanFactoryAware               | 获得当前bean factory ，即创建Bean的工厂        |
| ApplicationContextAware        | 当前的application context ，获取当前应用上下文 |
| MessageSourceAware             | 获得message source，这样可以获得文本信息       |
| ApplicationEventPublisherAware | 应用事件发布器，可以发布事件                   |
| ResourceLoaderAware            | 获得资源加载器，可以获得外部资源、文件         |



### ResponseBodyAdvice对Controller返回值进行二次封装

````java
@RestControllerAdvice
public class CommonResponseDataAdvice implements ResponseBodyAdvice<Object> {

    //只有当这个方法返回true的时候需要执行beforeBodyWrite方法
    @Override
    public boolean supports(MethodParameter methodParameter,
                            Class<? extends HttpMessageConverter<?>> aClass) {
		//如果类上包含IgnoreResponseAdvice注解忽略这个返回值
        if (methodParameter.getDeclaringClass().isAnnotationPresent(
                IgnoreResponseAdvice.class
        )) {
            return false;
        }
		//如果方法上包含IgnoreResponseAdvice注解忽略这个返回值
        if (methodParameter.getMethod().isAnnotationPresent(
                IgnoreResponseAdvice.class
        )) {
            return false;
        }
		//否则都需要对Controller的返回值进行封装
        return true;
    }

    @Nullable
    @Override
    public Object beforeBodyWrite(@Nullable Object o,
                                  MethodParameter methodParameter,
                                  MediaType mediaType,
                                  Class<? extends HttpMessageConverter<?>> aClass,
                                  ServerHttpRequest serverHttpRequest,
                                  ServerHttpResponse serverHttpResponse) {
		
        CommonResponse<Object> response = new CommonResponse<>(0, "");
        if (null == o) {
            //如果返回值为空,则返回自定义的空值响应
            return response;
        } else if (o instanceof CommonResponse) {
            //如果返回值类型是CommonResponse自定义的返回值,那么直接返回
            response = (CommonResponse<Object>) o;
        } else {
            //否则将返回值设置到自定义返回值的data中
            response.setData(o);
        }

        return response;
    }
}
````

````java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface IgnoreResponseAdvice {
}
````







