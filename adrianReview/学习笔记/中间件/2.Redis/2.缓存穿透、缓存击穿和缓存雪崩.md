### 缓存穿透

​		缓存穿透指请求<font color=red>在缓存中查不到数据</font>，<font color=blue>直接就去查询数据库</font>了

（每次查询都 “**视缓存于无物**”，也就是说每次查询都穿过缓存层，直接请求数据库层）

> 简单的说：恶意的请求直接查询数据库，导致数据库的压力大增从而导致数据库宕机

解决方案：

- 每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据



### 缓存击穿

​		缓存击穿指 某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，**<font color=red>当这个 key 在失效的瞬间</font>，大量的请求就击穿了缓存，直接请求数据库**，就像是在一道屏障上凿开了一个洞

解决方案：

- 可以将热点数据设置为永远不过期
- 基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据



### 缓存穿透和缓存击穿的区别

缓存穿透和缓存击穿最主要的区别是：

- 缓存击穿是 <font color=red>**key 在失效瞬间**</font>有大量请求击穿了缓存
- 而缓存穿透是缓存中没有相应的 key 而直接去查询了数据库



### 缓存雪崩

​		缓存雪崩是指 在高并发请求的情况下，<font color=red>缓存挂掉了，然后此时的查询请求都会落到数据库上，然后数据库就挂掉了</font>。然后重启数据库服务器的时候，立马又被新的请求给冲击，数据库又挂了

缓存雪崩的解决方案：

- 事前：
  - `redis` 高可用，主从+哨兵，`redis cluster`，避免全盘崩溃
- 事中：
  - 本地 `ehcache` 缓存 + `hystrix` 限流&降级，避免 `MySQL` 被打死
- 事后：
  - `redis` 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据



例子：

1. 用户发送一个请求，系统 A 收到请求后，先查本地 `ehcache` 缓存，如果没查到再查 `redis`。如果 `ehcache` 和 `redis` 都没有，再查数据库，将数据库中的结果，写入 `ehcache` 和 `redis` 中
2. 限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？**走降级**！可以返回一些默认的值，或者友情提示，或者空白的值