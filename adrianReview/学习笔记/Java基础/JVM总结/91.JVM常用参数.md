### 常用的JVM参数

1. `-Xmx -Xms` ：设置堆内存的最大值和最小值（jvm启动后，并不会直接让堆内存就扩大到指定的最大数值。而是会先开辟指定的最小堆内存，如果经过数次GC后，还不能，满足程序的运行，才会逐渐的扩容堆的大小，但也不是直接扩大到最大内存）

2. `-Xmn` ： 设置新生代的内存大小

3. `-Xss` ：设置栈的大小；因为栈是线程独占的内存空间，所以设置了这个值就等于每个线程的栈大小都是这个

4. `-XX:PermSize -XX:MaxPermSize` ：设置永久代的内存空间的最大值和最小值，永久区内存用光也会导致OOM的发生

5. <font color=red>`-XX:NewRatio`：设置新生代和老年代的比例</font>

6. <font color=red>`-XX:SurvivorRatio`：设置两个Survivor区和eden区的比例。默认：`-XX:SurvivorRatio=8`，即 8:1</font>

7. <font color=blue>`-XX:+PrintGCDetails`：打印GC的详细信息</font>

   ```java
   Heap
    PSYoungGen      total 76288K, used 6561K [0x000000076b400000, 0x0000000770900000, 0x00000007c0000000)
     eden space 65536K, 10% used [0x000000076b400000,0x000000076ba68458,0x000000076f400000)
     from space 10752K, 0% used [0x000000076fe80000,0x000000076fe80000,0x0000000770900000)
     to   space 10752K, 0% used [0x000000076f400000,0x000000076f400000,0x000000076fe80000)
    ParOldGen       total 175104K, used 0K [0x00000006c1c00000, 0x00000006cc700000, 0x000000076b400000)
     object space 175104K, 0% used [0x00000006c1c00000,0x00000006c1c00000,0x00000006cc700000)
    Metaspace       used 3068K, capacity 4496K, committed 4864K, reserved 1056768K
     class space    used 333K, capacity 388K, committed 512K, reserved 1048576K
   ```

   > - total的意思就是新生代的内存大小
   > - used也就是使用了多少内存大小
   > - 0x开头的那三个分别代表的是（也就是新生代这片内存的起始点，当前使用到的地方和最大的内存地点）
   >   - 底边界
   >   - 当前边界
   >   - 高边界

   - PSYoungGen：堆内存里面的新生代
     - eden space ：就是新生代的Eden区
     - from space/to  space：两个 Survivor 区
   - ParOldGen：堆内存的老年代
     - object space：
   - Metaspace：元空间
     - class space：类信息



8. `-XX:NewSize`  和 `-XX:MaxNewSize`：设置年轻代的大小，和年轻代的最大值

9. `-XX:MetaspaceSize`  和`-XX:MaxMetaspaceSize`：设置 `Metaspace` 的大小和最大值

10. `-XX:MaxTenuringThreshold`：长期存活的对象会被放入Old区，设置对象的最大存活年龄

    > 如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代

11. `-XX:+PrintTenuringDistribution`：设置Young区每发生GC的时候，就打印有效的对象的岁数情况

12. `-XX:MaxGCPauseMillis`：停顿时间；指垃圾收集器在进行垃圾回收时所中断应用执行的时间



#### 开启垃圾收集器

1. 开启串行收集器：
   - `-XX:+UseSerialGC`（Young区）
   - `-XX:+UseSerialOldGC`（Old区）
2. 开启并行收集器：
   - `-XX:+UseParallelGC`（Young区）
   - `-XX:+UseParallelOldGC`（Old区）
   - `-XX:ParallelGCThread=<N>` 设置N个GC线程，N取决于CPU核心数
3. 并发收集器在JDK1.8里有两个，一个是CMS，CMS因为具有响应时间优先的特点，所以是低延迟、低停顿的，CMS是老年代收集器。开启该收集器的参数如下：
   - `-XX:+UseParNewGC`（年轻代）
   - `-XX:+UseConcMarkSweepGC`（老年代）
4. G1，开启该收集器的参数如下：
   - `-XX:+UseG1GC`

