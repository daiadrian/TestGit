## final关键字

​	final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量），并且：

- 用 final 修饰的类不可以被继承
- 用 final 修饰的方法不可以被重写
- 用 final 修饰的属性一旦初始化以后就不可以被修改（指地址不能改变，如果修饰的是对象或者集合等，那么其内容可以被改变）



### final修饰类

​	当用final修饰一个类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注意<font color=blue>final类中的所有成员方法都会被隐式地指定为final方法</font>



#### 上转型对象

​	子类创建对象并将这个对象引用赋值给父类的对象，也就是多态。`Father f = new Son();`

1. 上转型对象是由子类创建的，但上转型对象会失去子类的一些属性和方法
2. 上转型对象调用方法时，就是调用子类继承和重写过的方法。而不会是新增的方法，也不是父类原有的方法
3. 上转型对象可以操纵父类原有的属性和功能，无论这些方法是否被重写
4. 上转型对象可以再强制转换到一个子类对象，强制转换过的对象具有子类所有属性和功能



#### 动态绑定和静态绑定

​	绑定指一个方法的调用与方法所在的类关联起来。java中的绑定分为静态绑定和动态绑定，又被称作前期绑定和后期绑定

1. **<font color=blue>静态绑定：</font>**（final、static、private）在程序执行前已经被绑定，也就是说在编译过程中就已经知道这个方法是哪个类的方法，此时由编译器获取其他连接程序实现

   > - private：不能被继承，则不能通过子类对象调用，而只能通过类本身的对象进行调用，所以可以说private方法和方法所属的类绑定
   >
   > - final：final方法虽然可以被继承，但是不能被重写（覆盖），虽然子类对象可以调用，但是调用的都是父类中的final方法（因此可以看出当类中的方法声明为final的时候，一是为了防止方法被覆盖，而是为了有效关闭 Java 的动态绑定）；
   >
   > - static：static方法可以被子类继承，但是不能被子类重写（覆盖），但是可以被子类隐藏
   >
   >   >  	意思是说如果父类里有一个static方法，它的子类里如果没有对应的方法，那么当子类对象调用这个方法时就会使用父类中的方法
   >   >
   >   > ​	而如果子类中定义了相同的方法，则会调用子类的中定义的方法。唯一的不同就是，当子类对象上转型为父类对象时（子类对象当作父类对象来使用），不论子类中有没有定义这个静态方法，该对象都会使用父类中的静态方法
   >   >
   >   > ​	因此说静态方法可以被隐藏而不能被覆盖。这与子类隐藏父类中的成员变量是一样的。隐藏和覆盖的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏的变量和方法，但不能访问父类被覆盖的方法

2. **<font color=blue>动态态绑定：</font>**在程序运行过程中，根据具体对象的类型进行绑定

​	

### final修饰方法

​		final方法表示该方法不能被子类的方法重写。将方法声明为final，在编译的时候就已经静态绑定了，不需要在运行时动态绑定



### final修饰变量

​		用 final 声明的属性正常情况下初始化一次后，就不会被改变。<font color=blue>当final修饰一个基本数据类型时</font>，表示该基本数据类型的值一旦在初始化后便不能发生变化；<font color=blue>如果final修饰一个引用类型时</font>，则在对其初始化之后便不能再让其指向其他对象了，<font color=red>**但该引用所指向的对象的内容是可以发生变化的**（引用的值是一个地址，final要求值，即地址的值不发生变化）</font>



​		**final修饰一个成员变量（属性），必须要显示初始化。** 这里有两种初始化方式：<font color=red>**（重点）**</font>

- 在变量声明的时候初始化
- 在声明变量的时候不赋初值，但是要在这个变量所在的类的**所有的构造函数**中对这个变量赋初值

​	

​		对于 final 属性的读操作，编译器可以自由地去除不必要的同步。相应地，编译器可以将 final 属性的值缓存在寄存器中，而不用像普通属性一样从内存中重新读取。

​		final 属性同时也允许程序员不需要使用同步就可以实现**线程安全**的**不可变对象**。一个线程安全的不可变对象对于所有线程来说都是不可变的，即使传递这个对象的引用存在数据竞争

​		对象只有在构造方法结束了才被认为**完全初始化**了。如果一个对象**完全初始化**以后，一个线程持有该对象的引用，那么这个线程一定可以看到正确初始化的 final 属性的值（如果属性值不是 final 的，那就不能保证一定可以看到正确初始化的值，可能看到初始零值，这跟类加载有关）

​	

### final修饰对象

final 修饰的对象指向的**内存地址不能发生改变**，但是<font color=blue>对象内的属性可以发生改变，这种情况下是线程不安全的</font>

