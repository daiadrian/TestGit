Map总结

## 散列表

​	散列表（Hash table，也叫哈希表），是根据关键码值（Key-value）而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表

​	给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到**包含该关键字的记录在表中的地址**，则称表M为哈希（Hash）表，函数f(key)为哈希（Hash） 函数

> 来源：百度百科

### 哈希冲突

​	对不同的关键字可能得到同一散列地址，即**k1≠k2**，而**f(k1)=f(k2)**，（即**hashCode散列码相同**）这种情况是无法避免的，这种现象称为散列冲突

<font color=green>**处理哈希冲突的常用方法有：**</font>

1. 开放地址法

   > ​	开放地址法就是一旦发生散列冲突，就去寻找下一个空的散列地址，直到找到一个空槽来放置这个元素（只要散列表足够大，空的散列表总能找到）

2. 链地址法

   > 将所有同义词的关键字存储在同一个单链表中，称这个单链表为同义词子表，在散列表中只存储同义词子表的头指针
   >
   > 只要有冲突，就在同义词的子表中增加结点（可以参考JDK1.7 HashMap 的存储实现，就是链地址法；JDK1.8中，链表达到一定程度会变成红黑树）

3. 再散列法

   > 散列表得到的每个列表可称之为桶。当散列表太满时（装载因子决定何时进行再散列），需要对散列表再散列，得到更多桶数的散列表，并且将原来散列表的元素按照新函数进行哈希操作插入到新的表中



## HashMap（JDK1.7）

### 小结

- JDK7的 HashMap 是数组+链表（**单向链表**）的数据结构
- 数组的容量始终保持 2^n ，达到扩容的阈值后会自动扩容，扩容后的数组容量会变成以前的 2 倍
- 当哈希冲突严重的时候，HashMap 会退化成链表

### 大致结构

1. `int threshold` 扩容的阈值，即当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值（即当前**<font color=red>数组的长度乘以加载因子</font>(`capacity * loadfactor`)**的值的时候），这个时候Map就要自动扩容了

2. `static final int DEFAULT_INITIAL_CAPACITY = 1 << 4` 默认的初始容量大小16（位桶的数量）

3. `static final int MAXIMUM_CAPACITY = 1 << 30` 最大的容量，2^31

4. `final float loadFactor` 负载因子，默认为 0.75（`static final float DEFAULT_LOAD_FACTOR = 0.75f`）

5. `Entry<K,V>` 链表中的实体是嵌套类 Entry 的实例

   ````java
   static class Entry<K,V> implements Map.Entry<K,V> {
       final K key;//HashMap的key
       V value;//HashMap的value
       Entry<K,V> next;//单向链表的next
       int hash;//key的hash值
       
       ....//省略
   }
   ````

### 构造方法

````java
//无参构造器
public HashMap() {
    //DEFAULT_INITIAL_CAPACITY = 1 << 4 = 16
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
}
//带初始化容量的构造器
public HashMap(int initialCapacity) {
    //DEFAULT_LOAD_FACTOR = 0.75f
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
//上面两个构造器均指向这个构造方法
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                         initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);

    this.loadFactor = loadFactor;
    threshold = initialCapacity;
    init();//初始化钩子方法
}
````

​	这些初始化方法很简单，只是赋值一些成员变量的值；HashMap 的数组是在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值

### 增删改查

#### put

````java
 public V put(K key, V value) {
     // 当插入第一个元素的时候，需要先初始化数组大小
     if (table == EMPTY_TABLE) {
         inflateTable(threshold);
     }
     //当 key 为null的情况，下面说
     if (key == null)
         return putForNullKey(value);
     //1. 计算 key 的hash值
     int hash = hash(key);
     //indexFor 中的代码是： return hash & (length-1);
     //2. 位运算符& 计算出该key对应的数组下标值
     int i = indexFor(hash, table.length);
     //3. 遍历对应数组下标处的单向链表 
     for (Entry<K,V> e = table[i]; e != null; e = e.next) {
         Object k;
         // 检查是否有重复的 key 已经存在，如果有，直接覆盖；然后返回旧值
         if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
             V oldValue = e.value;
             e.value = value;
             e.recordAccess(this);
             return oldValue;
         }
     }

     modCount++;
     //4. 到这里证明 （单向链表为空） 或者 （不存在重复的key值）
     addEntry(hash, key, value, i);
     return null;
}

//上面的 第4步
void addEntry(int hash, K key, V value, int bucketIndex) {
    // 如果数组长度大于扩容阈值就要进行数组的扩容操作了
    if ((size >= threshold) && (null != table[bucketIndex])) {
        //数组扩容操作，下面细讲
        resize(2 * table.length);
        //这里重新计算 key 在扩容后的数组中的下标志
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }
    createEntry(hash, key, value, bucketIndex);
}
//生成 Entry 实体，并且放入链表中
//这里值得注意的是，每次新加入链表的实体 Entry 都会放到链表头
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    size++;
}
````

**初始化数组大小**

```java
private void inflateTable(int toSize) {
    // Find a power of 2 >= toSize
    int capacity = roundUpToPowerOf2(toSize);

    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}

private static int roundUpToPowerOf2(int number) {
    // assert number >= 0 : "number must be non-negative";
    int rounded = number >= MAXIMUM_CAPACITY
        ? MAXIMUM_CAPACITY
        : (rounded = Integer.highestOneBit(number)) != 0
            ? (Integer.bitCount(number) > 1) ? rounded << 1 : rounded
            : 1;

    return rounded;
}
```

