String类详解

### String简述

​		String 类代表字符串。**字符串是常量，它们的值在创建之后不能更改**。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享

​		String底层使用一个字符数组来维护的。String类的值是final类型的，不能被改变的，所以只要一个值改变就会生成一个新的String类型对象，存储String数据也不一定从数组的第0个元素开始的，而是从offset所指的元素开始

​		String类采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象（仅适用于于直接赋值的创建方式）



### String创建方式

#### 直接赋值

`String str="hello";//直接赋值的方式`

直接赋值方式创建对象是在**<font color=red>方法区的常量池</font>**



#### 构造方法创建对象

`String str=new String("hello");//实例化的方式`

通过构造方法创建字符串对象是在**<font color=red>堆内存</font>**

​	不推荐这种方式创建String对象



### 比较(==)场景(重点)

````java
public class Test {

    public static void main(String[] args) throws Exception {
        /**
         *      由于常量的值在编译的时候就被确定(优化)了
         *         "ab"和"cd"都是常量，因此变量str3的值在编译时就可以确定
         */
        String str1 = "ab" + "cd";  //这行代码编译后的效果等同于：String str3 = "abcd";
        String str2 = "abcd";
        System.out.println("str1 = str2 : "+ (str1 == str2));//true


        /**
         * 局部变量str3,str4存储的是存储两个拘留字符串对象(intern字符串对象)的地址
         *
         *  String str5 = str3 + str4; 原理：
         *      
         *              1. 运行期JVM首先会在堆中创建一个 StringBuilder 类,
         *              
         *              2. 同时用 str3 指向的拘留字符串对象完成初始化,
         *              
         *              3. 然后调用append方法完成对 str4 所指向的拘留字符串的合并,
         *              
         *              4. 接着调用StringBuilder的toString()方法在 堆中 创建一个String对象, 		 *					(堆中,堆中,堆中创建)
         * 
         *              5. 最后将刚生成的String对象的 堆地址 存放在局部变量str5中.
         *
         *   str6存储的是字符串池中"abcd"所对应的拘留字符串对象的地址,所以str5与str6地址不一样
         *
         * 内存中实际上有 五个字符串对象：
         *       三个拘留字符串对象、一个String对象和一个StringBuilder对象
         *          
         *          拘留对象: str3, str4, str6
         *          string对象: str5
         *          StringBuilder: 合并str3 和 str4 产生的对象 
         */
        String str3 = "ab";  
        String str4 = "cd";  
        String str5 = str3 + str4;
        String str6 = "abcd";
        System.out.println("str5 = str6 : " + (str5==str6));//false

		/**
         * 运行期的两个string相加，会产生新的对象的，存储在堆(heap)中;例如str8
         *      这里跟上面 String str5 = str3 + str4; 是一样的
         *      运行期的相加会产生StringBuilder对象
         */
        String str7 = "b";
        String str8 = "a" + str7;
        String str9 = "ab";
        System.out.println("str8 = str9 : "+ (str8 == str9));//false

        /**
         * JAVA编译器对string + 基本类型/常量 是当成常量表达式直接求值来优化的
         *      此处final在编译期就已经被确定(优化)了
         */
        final String str10 = "b";
        String str11 = "a" + str10;
        String str111 = "a1";
        System.out.println("str11 = str111 : "+ (str11 == str111));//true
    }

}
````



### StringPool

​		字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在**编译时期**就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中

​		当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用



​		`new String("abc")` 使用这种方式一共会**<font color=red>创建两个字符串对象</font>**（前提是 String Pool 中还没有 "abc" 字符串对象）

- "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量
- 而使用 new 的方式会在堆中创建一个字符串对象（将上述的字符串常量作为构造函数的参数）



### String、StringBuilder、StringBuffer

#### 线程安全方面

线程安全：String、StringBuffer

线程不安全：StringBuilder



#### 执行效率

StringBuilder > StringBuffer > String 



#### 存储空间

​		String 的值是不可变的，每次对 String 的操作都会产生一个新的对象；效率低同时会消耗大量的内存空间，从而引发GC

​		StringBuffer 和 StringBuilder 都是可变的



#### 使用场景

1.  如果要操作少量的数据用 String
2. **单线程**操作字符串缓冲区 使用StringBuilder
3. **多线程**操作字符串缓冲区 使用StringBuffer