### HashCode方法特性

1. HashCode的存在主要是用于**查找的快捷性**，如Hashtable，HashMap等，HashCode经常用于**<font color=red>确定对象的存储地址</font>**

2. **如果两个对象相同**，equals方法一定返回true，并且这两个对象的**HashCode一定相同**

3. **两个对象的HashCode相同，并不一定表示两个对象就相同**，即equals()不一定为true，<font color=blue>只能够说明这两个对象在一个散列存储结构中</font>

4. 如果对象的equals方法被重写，那么对象**的HashCode也尽量重写**



### HashCode作用

​		Java中的集合有两类，一类是**List**，再有一类**是Set**。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素**不可重复**

​		**equals方法可用于保证元素不重复**，但如果每增加一个元素就检查一次，若集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了**哈希表的原理**

哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上

​		这样一来，<font color=blue>当集合要**添加新的元素时**，先调用这个**元素的HashCode方法**，就一下子能**定位到它应该放置的物理位置上**</font>

- 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了。

- 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了

- 不相同的话，也就是发生了Hash key相同导致**冲突的情况**，那么就在这个Hash key的地方产生一个链表，将所有产生相同HashCode的对象放到这个单链表上去，串在一起（很少出现）

