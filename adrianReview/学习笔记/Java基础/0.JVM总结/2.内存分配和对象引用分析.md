

> 本文基于JDK7 HotSpot VM

## 判定对象无用的根据

### 可达性分析算法

​		通过可达性算法判断对象是否不再使用。即GC Roots，将GC Roots作为起始点向下搜索引用，还被GC Roots引用的对象就是可用的，而当一个对象没有到GC Roots有任何引用链的即为可回收的对象

可作为GC Roots的对象：（<font color=red>注意：这些对象是在堆中存活的对象，而不是指栈中的变量</font>）

- 当前各线程执行方法中的局部变量（包括形参）引用的对象
- 已被加载的类的 static 域引用的对象
- 方法区中常量引用的对象
- JNI （Native方法）引用的对象



对于 Eclipse 的 MAT 工具，分析出来的 GC Roots 对象主要有：

- System class
- Native Stack（Native方法引用的对象）
- Thread：正在运行时的线程中调用的对象都可以作为根对象；方法的调用会产生一次栈帧，在栈帧中的被引用的对象都可以作为根对象
- Busy Monitor：指的是加锁的对象，例如加了 Synchronize 的对象是Root对象



#### 引用计数法的弊端

引用计数法最大的弊端就是循环引用，就是A引用B，而B也引用A。那么就造成内存泄漏





## 四种引用

### 引用的注意事项（必看）

- 引用也是一片内存空间，引用也可以叫做<font color=blue> **reference 类型的数据**</font>

- 当这个数据中存储的数值代表另外一块内存的起始地址，那么就称<font color=blue>这个数据是一个引用</font>
- 下面的几种引用，都是指这个 reference 类型的数据，然后由这个数据引用的对象才是被回收的对象。<font color=blue>这些类型的数据会由一个**引用队列进行存放，需要释放这些引用的内存时，就需要从这个队列中找到这些引用的内存地址，然后进行释放**</font>



### 强引用 

​		只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收 

类似 `Object obj = new Object();` 中，obj 就是强引用的对象



### 软引用（SoftReference） 

- 在垃圾回收之后，内存仍然不足够的时候，会将软引用的对象列入回收范围之中，然后再次进行垃圾回收，回收软引用的对象

- 可以配合引用队列来释放软引用自身 
- <font color=red>只有**当内存不够**的时候，才会在下一次的垃圾收集时回收掉软引用的对象</font>



### 弱引用（WeakReference） 

- 仅有弱引用引用该对象时，该对象只能活到下一次垃圾收集发生之前；当下一次垃圾回收时，无论内存是否足够，都会回收弱引用的对象

- 可以配合引用队列来释放弱引用自身 
- <font color=red>**无论内存够不够，都会**在下一次垃圾收集时回收掉弱引用的对象</font>



### 虚引用（PhantomReference） 

​		必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队（Reference Queue）， 由 Reference Handler 线程调用虚引用相关方法释放直接内存（调用 `Unsafe.freeMemory()` 来释放直接内存）



### 终结器引用（FinalReference） 

​		如果对象在进行可达性分析算法后没有发现到引用链，那么这些对象会被进行第一次标记并且会再进行一次筛选，筛选的条件是：该对象是否有必要执行 finalize() 方法

​		如果该对象没有覆盖 finalize() 方法或者这个方法已经被虚拟机调用过一次了，那么这些对象就会被第二次标志，然后被垃圾回收

​		如果该对象被判定有必要执行 finalize() 方法，那么这个对象会被放入一个 Finalizer-Queue 的队列中，再由 Finalizer 线程（低优先级的线程）通过终结器引用找到被引用对象并调用它的 finalize 方法。如果该对象在执行这个方法时重新与 GC ROOT 上的任何一个对象建立关联，那么就不会被回收掉

​		任何一个对象的 finalize() 方法只会被调用一次



## 内存的分配和回收

### 对象内存布局

​		在堆为对象分配内存空间之前，应该先知道对象在内存中存储的布局；对象在内存中的存储布局主要分为：对象头，实例数据和对齐填充。

- 对象头：主要用于存储对象自身运行时的数据和类型指针
  - 运行时数据包括：哈希码（HashCode）、GC分代年龄、锁状态标志
  - 类型指针是指向类元数据的指针
- 实例数据：对象中的字段数据和父类继承过来的字段数据等
- 对齐填充：只是起到占位符的作用。因为HotSpotVM要求对象的起始地址必须是8字节的整数倍，当一个对象的实例数据（对象头是32bit或者64bit）不是8字节的整数倍时，就需要对齐填充来补全了

### 对象内存分配

​        对象的内存分配主要在新生区的Eden空间上，当Eden区没有足够的连续空间时会触发一次MinorGC；但是一些需要连续大量内存空间的对象（很长的字符串或者数组）就会导致Eden区容纳不下这个对象（垃圾清理后仍然放不下），这个时候会直接在老年代中为其分配内存。

​		同时虚拟机也提供了 `-XX:PretenureSizeThreshold` 的参数，当对象的大小大于这个设置值的时候，会直接在老年代中进行内存分配，这样也可以避免新生代频繁的进行垃圾收集（新生代的垃圾收集是复制算法）

### 内存分配方式

​        了解了对象内存分配的位置，那么就需要知道内存分配的方式了。

1. 有大片连续内存空间时（常用于**带压缩算法**的收集器，如Serial，ParNew）

​        当存在大片连续的内存可用于分配给新对象时，可以采用**指针碰撞**的方式（每次分配对象空间只要检测一下是否有足够的空间，如果有那么指针往前移动 N 位就分配好空间了，然后就可以初始化这个对象了）

​		对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot 使用了称之为**Thread-Local Allocation Buffers (TLABs) 的技术**，该技术能改善多线程空间分配的吞吐量。TLABs首先给予每个线程一部分内存作为缓存区，<font color=blue>每个线程都在自己的缓存区中进行指针碰撞</font>，这样就不用获取全局锁了。只有当一个线程使用完了它的 TLAB，它才需要使用同步锁定来获取一个新的缓冲区。

​		HotSpot 使用了多项技术来降低 TLAB 对于内存的浪费。比如，TLAB 的平均大小被限制在 Eden 区大小的 1% 之内。TLABs 和使用指针碰撞的线性分配结合，使得内存分配非常简单高效。

> 可用-XX:+UseTLAB 来启用TLAB技术

2. 内存空间碎片较多时（如CMS收集器，使用Mark-Sweep算法）

​        当已经使用的内存和空闲内存相互交错的时候，就不能直接的进行指针碰撞来分配内存了；这个时候虚拟机就会维护一个 **“空闲列表”** 来记录可用的内存块，在分配内存的时候会再列表中找到足够大的空间划分给对象，并且会更新列表上的记录



### 内存分代思想

​		虚拟机采用了分代收集的思想去管理堆内存；分代思想指的是虚拟机根据对象的存活周期来划分内存，一般将堆内存划分为年轻代（新生代）和老年代；年轻代是在垃圾收集的时候会有大量的对象死去的内存区域，而老年代中的对象普遍是存活率高的

​		年轻代因为每次都有大量的对象死去，所以一般会采用复制算法（下文介绍，因为此算法只需要复制少量的存活对象，成本较低）；虚拟机在对象创建的时候会给对象定义一个<font color=red>对象年龄的计数器</font>，对象在年轻代（Eden区）被创建并且经历过一次Minor GC（年轻代垃圾收集）并且存活，将会被移到Survivor区并且设置对象年龄为1，<u>该对象每熬过一次MinorGC，对象年龄就会加一</u>，当对象年龄达到一定程度就会晋升到老年代中（默认是15，可以通过 `-XX:MaxTenuringThreshold=15` 来设置）

​		但是如果每个对象都需要等到晋升年龄的话，Survivor区不一定能够容纳下这么多的对象。所以为了应对这种内存状况，虚拟机的解决办法是：<font color=red>如果Survivor区中**相同年龄的所有对象大小的总和**大于Survivor空间的一半，那么对象年龄大于或等于该值的对象就直接进入老年代，不需要达到晋升年龄</font>



