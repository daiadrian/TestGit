### Java为什么需要常量池

​		字符串常量池有助于为Java运行时节省大量空间

> 为了减少在 `JVM` 中创建的字符串的数量，字符串类维护了一个字符串池
>
> 1. 每当代码创建字符串常量时，`JVM` 会首先检查字符串常量池
>
> 2. 如果字符串已经存在池中， 就返回池中的实例引用
> 3. 如果字符串不在池中，就会实例化一个字符串并放到池中
>
> ​        Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享



​		`JVM` 在栈帧（frame） 中进行操作数和方法的动态链接（link），为了便于链接，`JVM` 使用常量池来保存跟踪当前类中引用的其他类及其成员变量和成员方法

​		每个栈帧（frame）都包含一个运行常量池的引用，这个引用指向当前栈帧需要执行的方法，`JVM` 使用这个引用来进行动态链接

> ​		在 c/c++ 中，编译器将多个编译期编译的文件链接成一个可执行文件或者 `dll` 文件，在链接阶段，符号引用被解析为实际地址。`JAVA` 中这种链接是在程序运行时动态进行的



### 常量池

​		每个 `java` 文件编译为 class 文件后，都将产生当前类独有的常量池，我们称之为<font color=red>静态常量池</font>

​		class 文件中的常量池包含两部分：**字面值**（literal）和**符号引用**（Symbolic Reference）

> - 其中字面值可以理解为 `java` 中定义的字符串常量、final 常量等
> - 符号引用指的是一些字符串，这些字符串表示**<font color=blue>当前类引用的外部类、方法、变量等的引用地址</font>**的抽象表示形式，在类被 `jvm` 装载并第一次使用这些符号引用时，这些符号引用将会解析为直接引用

符号常量包含：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符



​		`jvm` 在进行类装载时，将class文件中常量池部分的常量加载到方法区中，此时方法区中的保存常量的逻辑区域称之为 <font color=red>运行时常量池</font>

#### 基础类型的包装类的缓存

基础类型包装类的缓存池使用一个数组进行缓存

- Integer 默认缓存 -128 ~ 127 区间的值，Long 和 Short 也是缓存了这个区间的值
- Byte 只能表示 -127 ~ 128 范围的值，全部缓存了
- Character 缓存了 0 ~ 127 的值
- Float 和 Double 没有缓存的意义

> 之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是**不可变类，即Final**



### StringPool常量池

​		String 类通过 String Pool 来缓存 String 对象。假设 "Java" 这个字符串我们会在应用程序中使用多次，我们肯定不希望在每次使用到的时候，都重新在堆中创建一个新的对象，那么就需要常量池进行共享了

​		JVM 内部使用 HashTable 进行缓存，我们知道，HashTable 的结构是一个数组，数组中每个元素是一个链表。和我们平时使用的 HashTable 不同，JVM 内部的这个 HashTable 是不可以动态扩容的



​		运行时常量池有一种 String 类型的常量，即通常我们所说的字符串字面值，所有的字符串字面值组成一个 String 常量表

​		String 常量表并不是一成不变的，程序运行时可以动态添加字符串常量，使用 String 的 `intern()` 可以动态的添加String常量

> ​		`jvm` 确保两个在值上完全相等的字符串字面值（即其中包含的字符序列是相同的，使用equals()来判断）**指向同一个 String 实例**
>
> ​		String 的`intern()`是一个 native 方法，返回的是一个String对象的标准表示。当调用该方法时，如果运行时常量池中已经存在与之相等的字符串（equal 方法相等），则直接返回常量池中的字符串引用，否则将此字符串添加到池中，并返回对应的字符串引用