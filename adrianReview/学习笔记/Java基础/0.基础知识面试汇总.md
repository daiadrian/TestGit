### 基本数据类型的比较

````java
Integer i01 = 59;
int i02 = 59;
Integer i03 =Integer.valueOf(59);
Integer i04 = new Integer(59);
````

i02为基本数据类型，有<font color=red>**基本数据类型的都是比较值**</font>

（所以 `i02 == i04` 返回的是 true）



​		JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象

### Switch关键字

<font color=green>**switch语句后的控制表达式只能是：**</font>

- short
- char
- int
- long整数类型
- 枚举类型
- **String类型是java7开始支持**

> ​		在 `switch(expr1)` 中，expr1只能是一个**整数表达式或者枚举常量（更大字体）**，整数表达式可以是int基本类型或Integer包装类型
>
> ​		由于<font color=blue>**byte、short、char都可以隐含转换为int**</font>，所以这些类型以及这些类型的包装类型也是可以的

<font color=red>**不能是：**</font>

- float
- double
- boolean类型

### Java反射

每个类都有一个 **Class** 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 `.class` 文件，该文件内容保存着 Class 对象。

​		类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 Class 对象

​		反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 `.class` 不存在也可以加载进来。

Class 和 `java.lang.reflect` 一起对反射提供了支持，`java.lang.reflect` 类库主要包含了以下三个类：

- **Field** ：可以使用 `get()` 和 `set()` 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 `invoke()` 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 的 `newInstance()` 创建新的对象



#### 优点

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率

#### 缺点

​		尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用

在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化



### Java泛型

在Java1.4及其之前的版本中，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。

​		泛型提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现 `ClassCastException`

​		**泛型是通过类型擦除来实现的**，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 `List<String>` 在运行时仅用一个List来表示。这样做的目的，是确保能和 Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型

#### 限定通配符和非限定通配符

1. 限定通配符
   - <? extends T>  它通过确保类型必须是  **T的子类**  来设定类型的 **上界**
   - <? super T>  它通过确保类型必须是  **T的父类**  来设定类型的 **下界**
2. 非限定通配符
   - `<?>` 表示了非限定通配符，因为 `<?>` 可以用任意类型来替代



### try-catch-finally 

1. 一旦在finally块中使用了 `return` 或 `throw` 语句，将会**导致try块，catch块中的 `return` ，`throw` 语句失效
2. 一个 try 块可能有多个 catch 块。Java虚拟机 会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块。即**只会执行第一个匹配块，catch只会匹配一个**；因为只要匹配了一个，虚拟机就会使整个语句退出



### 访问控制修饰符

|                    | private | default | protected | public |
| :----------------: | :-----: | :-----: | :-------: | :----: |
|     同一个类中     |    √    |    √    |     √     |   √    |
|     同一个包中     |         |    √    |     √     |   √    |
| 其它包中的子类内部 |         |         |     √     |   √    |
|     全局范围内     |         |         |           |   √    |



| **修饰符**             | **类** | **成员访求** | **构造方法** | **成员变量** | **局部变量** |
| ---------------------- | ------ | ------------ | ------------ | ------------ | ------------ |
| abstract（抽象的）     | √      | √            | －           | －           | －           |
| static （静态的）      | －     | √            | －           | √            | －           |
| public（公共的）       | √      | √            | √            | √            | －           |
| protected（受保护的）  |        | √            | √            | √            | －           |
| private（私有的）      | －     | √            | √            | √            | －           |
| synchronized（同步的） | －     | √            | －           | －           | －           |
| native（本地的）       | －     | √            | －           | －           | －           |
| transient（暂时的）    | －     | －           | －           | √            | －           |
| volatie（易失的）      | －     | －           | －           | √            | －           |
| final（不要改变的）    | √      | √            | －           | √            | √            |



### i++和++i

Java使用了中间缓存变量机制：

**<font color=red>x++表示先运算，再自增</font>**

**<font color=red>++x表示先自增再参与运算</font>**

````java
i=i++;
等同于：
	temp=i； 
	i=i+1;      
	i=temp;  
//分割线--------------------------
i=++i;
则等同于：
	i=i+1;
	temp=i;
	i=temp;
````



### Math工具类

#### ceil 和 floor

- `Math.ceil(d1)` ：ceil 方法上有这么一段注释：

  > If the argument value is less than zero but greater than -1.0, then the result is negative zero

  意思是：如果参数小于0且大于 -1.0，结果为 -0

- `Math.floor(d1)`：ceil 和 floor 方法 上都有一句话：

  > If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument

  意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，如果是 -0.0，那么其结果是 -0.0



### 字符串反转

利用 `StringBuffer` 或者 `StringBuilder` 的 `reverse()` 方法即可

````java
String str = "adrian";
StringBuffer stringBuffer = new StringBuffer(str);
stringBuffer.reverse().toString()
````



### 怎么确保一个集合不能被修改

````java
Collections.unmodifiableList(List list);
Collections.unmodifiableSet(Set set);
Collections.unmodifiableMap(Map m);

//带顺序的
Collections.unmodifiableSortedMap(Map m);
Collections.unmodifiableSortedSet(Set set);
````

​		调用这个方法返回的 集合 内容不可以被修改，如果修改会抛出异常`java.lang.UnsupportedOperationException`



### IO

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：`File`
- 字节操作：`InputStream` 和 `OutputStream`
- 字符操作：`Reader` 和 `Writer`
- 对象操作：`Serializable`
- 网络操作：`Socket`
- 新的输入/输出：`NIO`



#### 装饰者模式的应用

Java I/O 使用了装饰者模式来实现。以 `InputStream` 为例：

- `InputStream` 是抽象组件
- `FileInputStream` 是 `InputStream` 的子类，属于具体组件，提供了字节流的输入操作
- `FilterInputStream` 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 `BufferedInputStream` 为 `FileInputStream` 提供缓存的功能



​		实例化一个具有缓存功能的字节流对象时，只需要在 `FileInputStream` 对象上再套一层 `BufferedInputStream` 对象即可

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```



#### 序列化

序列化就是将一个对象转换成字节序列，方便存储和传输

- 序列化：`ObjectOutputStream.writeObject()`
- 反序列化：`ObjectInputStream.readObject()`

不会对**静态变量**进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。

​		序列化的类需要实现 `Serializable` 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常

​		`transient` 关键字可以使一些属性不会被序列化。

> ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据



### 继承相关问题

1. 子父类方法调用

   > ​		子类调用方法的时候：如果子类重写了父类的方法，那么会直接调用子类自身的方法，当在子类找不到该方法时，才会调用父类的方法



### byte 计算问题

```java
byte b1=1,b2=2,b3,b6; 
final byte b4=4,b5=6; 
b6=b4+b5; 
b3=(b1+b2);//编译出错
```

​		被final修饰的变量是常量，这里的 `b6=b4+b5` 可以看成是 `b6=10`；在**编译时**就已经变为 `b6=10` 了

​		b1 和 b2 是`byte`类型，Java中进行**<font color=red>计算时候将他们转换为int类型</font>**，再进行计算，`b1+b2` 计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。

​		<font color=blue>Java中的 byte，short，char 进行**计算时**都会隐式的转换为 int类型</font>



### 数组复制方法

​	复制的效率 `System.arraycopy` > `clone` > `Arrays.copyOf` > `for循环` 

- System类源码中给出了 `arraycopy` 的方法，**是native方法**，也就是本地方法，肯定是最快的
- `Arrays.copyOf` 的实现，在源码中是调用 `System.copyOf` 的，多了一个步骤，肯定就不是最快的



### 为什么要设计迭代器

​		迭代器本质是一种设计模式，为了解决为不同的集合类**<font color=red>提供统一的遍历操作接口</font>**

