### 基本数据类型的比较

````java
Integer i01 = 59;
int i02 = 59;
Integer i03 =Integer.valueOf(59);
Integer i04 = new Integer(59);
````

i02为基本数据类型，有<font color=red>**基本数据类型的都是比较值**</font>

（所以 `i02 == i04` 返回的是 true）



​		JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象

### Switch关键字

<font color=green>**switch语句后的控制表达式只能是：**</font>

- short
- char
- int
- long整数类型
- 枚举类型
- **String类型是java7开始支持**

> ​		在 `switch(expr1)` 中，expr1只能是一个**整数表达式或者枚举常量（更大字体）**，整数表达式可以是int基本类型或Integer包装类型
>
> ​		由于<font color=blue>**byte、short、char都可以隐含转换为int**</font>，所以这些类型以及这些类型的包装类型也是可以的

<font color=red>**不能是：**</font>

- float
- double
- boolean类型

### Java反射

每个类都有一个 **Class** 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 `.class` 文件，该文件内容保存着 Class 对象。

​		类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 Class 对象

​		反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 `.class` 不存在也可以加载进来。

Class 和 `java.lang.reflect` 一起对反射提供了支持，`java.lang.reflect` 类库主要包含了以下三个类：

- **Field** ：可以使用 `get()` 和 `set()` 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 `invoke()` 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 的 `newInstance()` 创建新的对象



#### 优点

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率

#### 缺点

​		尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用

在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化



### Java泛型

在Java1.4及其之前的版本中，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。

​		泛型提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现 `ClassCastException`

​		**泛型是通过类型擦除来实现的**，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 `List<String>` 在运行时仅用一个List来表示。这样做的目的，是确保能和 Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型

#### 限定通配符和非限定通配符

1. 限定通配符
   - <? extends T>  它通过确保类型必须是  **T的子类**  来设定类型的 **上界**
   - <? super T>  它通过确保类型必须是  **T的父类**  来设定类型的 **下界**
2. 非限定通配符
   - `<?>` 表示了非限定通配符，因为 `<?>` 可以用任意类型来替代



### try-catch-finally 

1. 一旦在finally块中使用了 `return` 或 `throw` 语句，将会导致try块，catch块中的 `return` ，`throw` 语句失效
2. 一个 try 块可能有多个 catch 块。Java虚拟机 会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块。即**只会执行第一个匹配块，catch只会匹配一个**；因为只要匹配了一个，虚拟机就会使整个语句退出



### 访问控制修饰符

|                    | private | default | protected | public |
| :----------------: | :-----: | :-----: | :-------: | :----: |
|     同一个类中     |    √    |    √    |     √     |   √    |
|     同一个包中     |         |    √    |     √     |   √    |
| 其它包中的子类内部 |         |         |     √     |   √    |
|     全局范围内     |         |         |           |   √    |



| **修饰符**             | **类** | **成员访求** | **构造方法** | **成员变量** | **局部变量** |
| ---------------------- | ------ | ------------ | ------------ | ------------ | ------------ |
| abstract（抽象的）     | √      | √            | －           | －           | －           |
| static （静态的）      | －     | √            | －           | √            | －           |
| public（公共的）       | √      | √            | √            | √            | －           |
| protected（受保护的）  |        | √            | √            | √            | －           |
| private（私有的）      | －     | √            | √            | √            | －           |
| synchronized（同步的） | －     | √            | －           | －           | －           |
| native（本地的）       | －     | √            | －           | －           | －           |
| transient（暂时的）    | －     | －           | －           | √            | －           |
| volatie（易失的）      | －     | －           | －           | √            | －           |
| final（不要改变的）    | √      | √            | －           | √            | √            |



### i++和++i

Java使用了中间缓存变量机制：

**<font color=red>x++表示先运算，再自增</font>**

**<font color=red>++x表示先自增再参与运算</font>**

````java
i=i++;
等同于：
	temp=i； 
	i=i+1;      
	i=temp;  
//分割线--------------------------
i=++i;
则等同于：
	i=i+1;
	temp=i;
	i=temp;
````



### Math工具类

#### ceil 和 floor

- `Math.ceil(d1)` ：ceil 方法上有这么一段注释：

  > If the argument value is less than zero but greater than -1.0, then the result is negative zero

  意思是：如果参数小于0且大于 -1.0，结果为 -0

- `Math.floor(d1)`：ceil 和 floor 方法 上都有一句话：

  > If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument

  意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，如果是 -0.0，那么其结果是 -0.0



### 字符串反转

利用 `StringBuffer` 或者 `StringBuilder` 的 `reverse()` 方法即可

````java
String str = "adrian";
StringBuffer stringBuffer = new StringBuffer(str);
stringBuffer.reverse().toString()
````



### 怎么确保一个集合不能被修改

````java
Collections.unmodifiableList(List list);
Collections.unmodifiableSet(Set set);
Collections.unmodifiableMap(Map m);

//带顺序的
Collections.unmodifiableSortedMap(Map m);
Collections.unmodifiableSortedSet(Set set);
````

​		调用这个方法返回的 集合 内容不可以被修改，如果修改会抛出异常`java.lang.UnsupportedOperationException`



### IO

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：`File`
- 字节操作：`InputStream` 和 `OutputStream`
- 字符操作：`Reader` 和 `Writer`
- 对象操作：`Serializable`
- 网络操作：`Socket`
- 新的输入/输出：`NIO`



#### 装饰者模式的应用

Java I/O 使用了装饰者模式来实现。以 `InputStream` 为例：

- `InputStream` 是抽象组件
- `FileInputStream` 是 `InputStream` 的子类，属于具体组件，提供了字节流的输入操作
- `FilterInputStream` 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 `BufferedInputStream` 为 `FileInputStream` 提供缓存的功能



​		实例化一个具有缓存功能的字节流对象时，只需要在 `FileInputStream` 对象上再套一层 `BufferedInputStream` 对象即可

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```



### 继承相关问题

1. 子父类方法调用

   > ​		子类调用方法的时候：如果子类重写了父类的方法，那么会直接调用子类自身的方法，当在子类找不到该方法时，才会调用父类的方法



### byte 计算问题

```java
byte b1=1,b2=2,b3,b6; 
final byte b4=4,b5=6; 
b6=b4+b5; 
b3=(b1+b2);//编译出错
```

​		被final修饰的变量是常量，这里的 `b6=b4+b5` 可以看成是 `b6=10`；在**编译时**就已经变为 `b6=10` 了

​		b1 和 b2 是`byte`类型，Java中进行**<font color=red>计算时候将他们转换为int类型</font>**，再进行计算，`b1+b2` 计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。

​		<font color=blue>Java中的 byte，short，char 进行**计算时**都会隐式的转换为 int类型</font>



### 数组复制方法

​	复制的效率 `System.arraycopy` > `clone` > `Arrays.copyOf` > `for循环` 

- System类源码中给出了 `arraycopy` 的方法，**是native方法**，也就是本地方法，肯定是最快的
- `Arrays.copyOf` 的实现，在源码中是调用 `System.copyOf` 的，多了一个步骤，肯定就不是最快的



### 为什么要设计迭代器

​		迭代器本质是一种设计模式，为了解决为不同的集合类**<font color=red>提供统一的遍历操作接口</font>**



### 包装类型和基本数据类型区别

1. 包装类型可以为 null，基本类型不可以

2. 包装类型可以应用于**泛型**，基本类型不可以

3. 基本类型比包装类型更高效

   > **基本类型在<font color=red>栈中</font>直接存储的具体数值**，而包装类型则存储的是堆中的引用

4. 自动装箱和自动拆箱

   > - 把基本类型转换成包装类型的过程叫做装箱（`boxing`）
   > - 把包装类型转换成基本类型的过程叫做拆箱（`unboxing`）
   >
   > ```java
   > Integer chenmo  = 10;  // 自动装箱
   > int wanger = chenmo;   // 自动拆箱
   > ```



#### 自动装箱

```java
Integer c = 100;
Integer d = 100;
System.out.println(c == d);
// 答案是 false
```

解释：

自动装箱是通过 `Integer.valueOf()` 完成的

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

-128 到 127 之间的数会从 `IntegerCache` 中取（也就是缓存池）

所以，**当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象**



### JDK和JRE的区别

- `JDK` 是面向开发人员使用的 `SDK` （Software Development Kit：软件开发工具包）

- `JRE` 是 `Java Runtime Enviroment` 是指 **Java的运行环境**，是面向Java程序的使用者