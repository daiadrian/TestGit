二进制知识点汇总



## 以SnowFlake算法为例子理解一下位数运算

### 负数的二进制表示

在计算机中，负数的二进制是用`补码`来表示的。
假设我是用Java中的int类型来存储数字的，
int类型的大小是32个二进制位（bit），即4个字节（byte）。（1 byte = 8 bit）
那么十进制数字`3`在二进制中的表示应该是这样的：

```
00000000 00000000 00000000 00000011  //3的二进制表示，就是原码
```

那数字`-3`在二进制中应该如何表示？
我们可以反过来想想，因为-3+3=0，
在二进制运算中，把-3的二进制看成未知数x来求解，
求解算式的二进制表示如下：

```
   00000000 00000000 00000000 00000011 //3，原码
+  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx //-3，补码
-----------------------------------------------
   00000000 00000000 00000000 00000000
```

反推x的值，3的二进制加上什么值才使结果变成`00000000 00000000 00000000 00000000`？：

```
   00000000 00000000 00000000 00000011 //3，原码                         
+  11111111 11111111 11111111 11111101 //-3，补码
-----------------------------------------------
 1 00000000 00000000 00000000 00000000
```

反推的思路是3的二进制数从最低位开始逐位加1，使溢出的1不断向高位溢出，直到溢出到第33位。然后由于int类型最多只能保存32个二进制位，所以最高位的1溢出了，剩下的32位就成了（十进制的）0。

**补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个“溢出的0”**

以上是理解的过程，实际中记住**公式**就很容易算出来：

- 补码 = 反码 + 1
- 补码 = （原码 - 1）再取反码

因此`-1`的二进制应该这样算：

```
00000000 00000000 00000000 00000001 //原码：1的二进制
11111111 11111111 11111111 11111110 //取反码：1的二进制的反码
11111111 11111111 11111111 11111111 //加1：-1的二进制表示（补码）
```

### 用位运算计算n个bit能表示的最大数值

比如这样一行代码：

```
    private long workerIdBits = 5L;
    private long maxWorkerId = -1L ^ (-1L << workerIdBits);       
```

上面代码换成这样看方便一点：
`long maxWorkerId = -1L ^ (-1L << 5L)`

咋一看真的看不准哪个部分先计算，于是查了一下Java运算符的优先级表:
![图片描述](https://segmentfault.com/img/bVVt9g?w=400&h=373)

所以上面那行代码中，运行顺序是：

- -1 左移 5，得结果a
- -1 异或 a

`long maxWorkerId = -1L ^ (-1L << 5L)`的二进制运算过程如下：

**-1 左移 5，得结果a ：**

```
        11111111 11111111 11111111 11111111 //-1的二进制表示（补码）
  11111 11111111 11111111 11111111 11100000 //高位溢出的不要，低位补0
        11111111 11111111 11111111 11100000 //结果a
```

**-1 异或 a ：**

```
        11111111 11111111 11111111 11111111 //-1的二进制表示（补码）
    ^   11111111 11111111 11111111 11100000 //两个操作数的位中，相同则为0，不同则为1
---------------------------------------------------------------------------
        00000000 00000000 00000000 00011111 //最终结果31
```

最终结果是31，二进制`00000000 00000000 00000000 00011111`转十进制可以这么算：

2^4+2^3+2^2+2^1+20=16+8+4+2+1=31

​	那既然现在知道算出来`long maxWorkerId = -1L ^ (-1L << 5L)`中的`maxWorkerId = 31`，有什么含义？为什么要用左移5来算？

> `5位（bit）`可以表示的最大正整数是$2^{5}-1 = 31$，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId

​	-1L ^ (-1L << 5L)`结果是`31`，$2^{5}-1$的结果也是`31`，所以在代码中，`-1L ^ (-1L << 5L)`的写法是`利用位运算计算出5位能表示的最大正整数是多少