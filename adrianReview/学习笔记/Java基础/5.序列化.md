## 序列化

### 序列化简介

​		**对象序列化**是指将Java对象（动态的状态，如变量、函数）转换为字节流（二进制形式）的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序（即方便存储和传输）

​		**反序列化：**从字节流重构出Java对象的过程

​		序列化的类需要实现 `Serializable` 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常



### 序列化的作用

1. 对象持久化，序列化后可以将对心存储到磁盘
2. 进行网络传输



### 如何进行序列化

1. 使用 IO 包的对象
   - 序列化：`ObjectOutputStream.writeObject()`
   - 反序列化：`ObjectInputStream.readObject()`
2. 实现序列化接口 `Java.lang.Serializable` ；这是一个标志接口



### 序列化特殊情况

1. 不会对**静态变量**进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态

2. `transient` 关键字可以使一些属性不会被序列化

   > ​	`ArrayList` 中存储数据的数组 `elementData` 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据

3. 序列化版本问题

   > - 问题：在完成序列化操作后，由于项目的升级或修改，可能我们会对序列化对象进行修改，比如**增加某个字段，那么我们在进行反序列化就会报错**
   >
   > - 解决办法：在 `JavaBean` 对象中增加一个 `serialVersionUID` 字段，用来固定这个版本，无论我们怎么修改，版本都是一致的，就能进行反序列化了
   >
   >   `private static final long serialVersionUID = 8656128222714547171L;`
   >
   > - 原因：
   >
   >   > - 虚拟机是否允许对象反序列化，不是取决于该对象所属类路径和功能代码是否与虚拟机加载的类一致，而是**<font color=red>主要取决于对象所属类与虚拟机加载的该类的序列化 ID 是否一致</font>**
   >   > - Java 的序列化机制是通过在运行时判断类的 `serialVersionUID` 来验证版本一致性。在进行反序列化时，JVM 会把传来的**字节流**中的 `serialVersionUID` 与**本地实体类**中的 `serialVersionUID` 进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常

4. 反序列化时要按照序列化的顺序重构对象

   > 如先序列化A后序列化B，则反序列化时也要先获取A后获取B，否则报错

5. 自定义序列化方法的应用场景

   >  对**某些敏感数据进行加密操作后再序列化**；反序列化对加密数据进行解密操作

6. 重复序列化

   > ​		同一个对象重复序列化时，不会把对象内容再次序列化，而是新增一个引用指向第一次序列化时的对象而已