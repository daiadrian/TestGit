并发编程核心容器和工具类

## 多线程的三大特性

#### 原子性

​		是指一个操作是不可中断的

#### 内存可见性

​		指线程之间的可见性，一个线程修改的状态对另一个线程是可见的

​		也就是说在主存上的共享变量，在其他线程使用的时候会拷贝一份到自己的工作线程中使用，对于主存上的共享变量的修改，每个工作线程都是能够可见的

#### 重排序

​		指的程序执行的顺序按照代码的顺来来执行。但是一般JVM为了执行的效率，会将程序的指令进行重排序

​		指令的重排序对于单线程的程序是不影响最后的执行结果的，但是在并发的情况下会产生问题

**导致共享变量在线程间不可见的原因**

- 线程交叉执行

- 重排序结合线程交叉执行

- 没有在工作空间和主存空间及时更新值

## CAS操作

​		CAS（`CompareAndSwapInt`）又称无锁操作，是一种乐观锁机制

​		CAS指令有两个步骤：冲突检测和更新操作，这两个步骤合起来成为一个原子性操作。CAS指令需要3个操作数：内存位置（V），旧的预期值（A），新值（B）。

​		CAS指令执行时，首先比较内存位置 V 处的值和 A 的值是否相等（冲突检测），如果相等，就用新值B覆盖A（更新操作），否则，就什么也不做。<u>当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程</u>



## 容器

### CopyOnWrite容器

#### 什么是CopyOnWrite容器

​		其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略

​		`CopyOnWrite` 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是<font color=red>**先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器**</font>

​		这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器

> ​		从JDK1.5开始Java并发包里提供了两个使用 `CopyOnWrite` 机制实现的并发容器,它们是 `CopyOnWriteArrayList` 和 `CopyOnWriteArraySet`
>
> ​		`CopyOnWrite`容器非常有用，可以在非常多的并发场景中使用到

#### CopyOnWrite的使用

​		Cow可以解决list在并发场景下读和写同时操作下不会出现异常。但是Cow会有内存开销过大的问题，因为 `CopyOnWrite` 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象；如果数据量过大，那么对性能和内存开销会变得很大，这种场景下不建议使用。因此它更适合读多写少的场景（<font color=green>**用作缓存**</font>）

````java
public class Test {
	public static void main(String[] args) throws Exception {
		List<String> a = new ArrayList<String>();
		a.add("a");
		a.add("b");
		a.add("c");
		final CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>(a);
		Thread t = new Thread(new Runnable() {
			int count = -1;
			@Override
			public void run() {
				while (true) {
					list.add(count++ + "");
				}
			}
		});
		t.setDaemon(true);
		t.start();
		Thread.currentThread().sleep(3);
        //并发读写不会抛出异常
		for (String s : list) {
			System.out.println(list.hashCode());
			System.out.println(s);
		}
	}
}
````



### Volatile关键字

#### 作用

1. 内存可见性

   > ​		在对volatile修饰的变量进行读操作的时候，会先加载(load)主内存中最新的值
   >
   > ​		在对volatile修饰的变量进行写操作的时候，会在写之后将工作空间的变量值更新到主内存中

2. 禁止指令重排序

   > ​		指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理



## Atomic原子操作类

​		Atomic类主要依赖**CAS操作**来实现并发操作下的原子性

#### AtomicBoolean让代码只执行一次

````java
public class TestAtomicBoolean {
    private static AtomicBoolean aBoolean = new AtomicBoolean(false);
    public static void main(String[] args) {
        HashMap<Integer, String> map = new HashMap<>();
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    if (aBoolean.compareAndSet(false, true)) {
                        map.put(finalI, "testAtomicBoolean");
                    }
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("map一共插入了：" + map.size());
		// output : 1
    }
}
````





