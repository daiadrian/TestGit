多线程总结

## 概念理解

### 并行和并发

1. 并行：

   - 并行是指**同一时刻内**发生两个或多个事件
   - 并行是在**不同**实体上的多个事件

2. 并发：

   - 并发是指**同一时间间隔内**发生两个或多个事件
   - 并发是在**同一实体**上的多个事件

   > ​        <font color=blue>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程</font>
   >
   > ​        <font color=blue>它只能把**CPU运行时间划分成若干个时间段**，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发（Concurrent）</font>



### 进程和线程

1. 进程：

​	进程是**程序的一次执行**，进程是一个程序及其数据在处理机上顺序执行时所发生的**活动**，进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源**分配和调度的一个独立单位**

​	进程是系统进行资源分配和调度的独立单位。每一个进程都有它自己的内存空间和系统资源



2. 线程：

​        线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

​	**在多核或多CPU**上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常**被阻塞的部分**与密集计算的部分分开来执行，编写专门的workhorse（任务繁重的）线程执行密集计算，从而提高了程序的执行效率



- **线程的属性**：

  - 轻型实体（线程中的实体基本上不拥有系统资源，但是该实体必须是保证独立运行的资源）
  - 独立调度和分派的基本单位
  - 可并发执行
  - 共享进程资源

- **线程的3个基本状态**：执行、就绪、阻塞

- **线程的5种基本操作**：派生、阻塞、激活、调度、结束

- **线程的两个基本类型**：

  - 用户级线程：管理过程全部由用户程序完成，操作系统内核心只对进程进行管理
  - 系统级线程（核心级线程）：由操作系统内核进行管理。操作系统内核给应用程序提供相应的系统调用和应用程序接口API，以使用户程序可以创建、执行以及撤消线程

- **<font color=red>多线程</font>**：指的是一个进程运行时产生了多个线程完成不同的工作

  <font color=red>注意：</font>**多线程不是提高程序的执行速度！！！**

  1. **多线程的优点**：

     - 资源的利用率更高
     - 程序响应速度更快

     > ​        当程序中某个任务因为某些条件（通常是I/O操作）导致不能继续执行（即阻塞），如果没有多线程，那么整个程序都会停下来等待。反之有多线程的情况下，CPU就会切换到程序的其他线程继续执行，这样就能提高程序的性能

  2. **多线程的代价**：

     - 上下文的开销

       > ​        当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”
       >
       > ​	CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。上下文切换并不廉价，如果没有必要，应该减少上下文切换的发生

     - 增加资源消耗（需要用内存来维持线程本地的堆栈）



### 多线程存在的问题

1. 共享的数据

   - **共享数据能够被系统中的其他线程修改**；线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）
   - 线程执行顺序是不确定的，贡献的数据结构在任何一个时间只有一个或者很少的线程能够访问，这样会导致在这些共享数据结构上出现竞争状态，会导致出现一定程度的串行化（有可能前一个修改被后一个覆盖导致修改并没有正常执行）
     - 线程竞态：竞态问题在多个线程对共享资源进行写操作的时候才会发生（对资源的访问顺序敏感），当多个线程只是对共享资源进行读操作的时候是线程安全的

2. 死锁

   ​	线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候

   > 例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁



#### 解决方案

1. 线程间不共享数据
2. 使用final使共享变量不可变
3. 加锁（AQS框架）
4. 使用JDK提供的类和关键字来实现线程安全
   - volatile关键字
   - 同步代码块Synchronize
   - 原子类（AtomicBoolean等）
   - 容器（ConcurrentHashMap等）
   - 等等...
5. 更多方式等...



### 并发内存模型

#### 并发三问题

1. 重排序

   - 编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排
   - 指令重排序：CPU 优化行为，也是会对不存在数据依赖关系的指令进行一定程度的重排
   - 内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为

2. 内存可见性

   - 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的（如果每个核心共享同一个缓存，那么也就不存在内存可见性问题了）
   - 现代多核 CPU 中每个核心拥有自己的一级缓存或一级缓存加上二级缓存等，问题就发生在每个核心的独占缓存上。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个**过期**的值
   - 所有的共享变量存在于主内存中，**每个线程有自己的本地内存**，线程读写共享数据也是通过本地内存交换的

3. 原子性

   - **一个操作是不可中断的，要么全部执行成功要么全部执行失败**

   - 在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰



#### 内存间相互交互

​	关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是原子的、不可再分的：

1. **lock（锁定）**：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态
2. **unlock（解锁）**：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. **read（读取）**：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
4. **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
5. **use（使用）**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
6. **assign（赋值）**：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
7. **store（存储）**：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
8. **write（写入）**：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中



**Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则：**

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了滞后必须把该变化同步回主内存
- 不允许一个线程无原因地把数据从线程的工作内存同步回主内存中
- 一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量
- <font color=red>**一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁**</font>
- <font color=blue>**如果对同一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值**</font>
- 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量
- **对一个变量执行unlock操作之前，必须先把此变量同步回主内存中**



### 线程安全相关



#### 不可变对象

​		**<font color=red>不可变（Immutable）的对象一定是线程安全的</font>**，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全

不可变的类型：

- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 `Long` 和 `Double` 等数值包装类型，`BigInteger` 和 `BigDecimal` 等大数据类型。但同为 Number 的原子类 `AtomicInteger` 和 `AtomicLong` 则是可变的。

对于**集合类型**，可以使用 `Collections.unmodifiableXXX()` 方法来获取一个不可变的集合

> `Collections.unmodifiableXXX()` 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常 `UnsupportedOperationException`



#### 互斥(阻塞)同步

`synchronized` 和 `ReentrantLock`



#### 非阻塞同步

​		互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步

​		**互斥同步属于一种悲观的并发策略**。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作

​		非阻塞同步的方案有 CAS、Atomic 类



#### 无同步方案

##### 栈封闭

​		多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的

​		局部变量在栈内存中，不同线程间的栈内存是不可见的，所以是线程安全的



