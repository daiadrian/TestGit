## Synchronized关键字

​		`Synchronized` 关键字<font color=red>解决的是多个线程之间访问资源的同步性</font>，`synchronized` 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行

Synchronized关键字是一种同步锁，它可以修饰：

1. **代码块**：被修饰的代码块称为同步语句块，作用的对象是调用这个代码块的对象
2. **普通方法**：被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象
3. **静态方法**：其作用的范围是整个静态方法，作用的对象是类对象

<font color=red>注意</font>：<font color=green>**对 Class 对象加锁、对对象加锁，它们之间不构成同步**。synchronized 作用于静态方法时是对 **Class 对象**加锁，作用于实例方法时是对实例加锁</font>



### Synchronized内存可见性

**JVM对synchronized的规定**：

1. 线程解锁前必须要将最新值更新到主存空间

2. 线程加锁时，需要先清空工作空间的共享变量的值，从主存中读取最新的值到工作空间



​		一个线程在获取到监视器锁以后才能进入 synchronized 控制的代码块，一旦进入代码块；首先该线程对于共享变量的缓存就会失效，因此 synchronized 代码块中对于共享变量的读取需要从主内存中重新获取，也就能获取到最新的值

​		退出代码块的时候，会将该线程写缓冲区中的数据刷到主内存中，所以在 synchronized 代码块之前或 synchronized 代码块中对于共享变量的操作随着该线程退出 synchronized 块，会立即对其他线程可见（前提是其他读取共享变量的线程会从主内存读取最新值）

> 注意：在进入 synchronized 的时候，并不会保证之前的写操作刷入到主内存中，<font color=red>synchronized 主要是保证退出的时候能将本地内存的数据刷入到主内存</font>



### 单例模式中的双重检查存在的问题

````java
public class Singleton {

    private static Singleton instance = null;
    private int v;
    private Singleton() {
        this.v = 3;
    }

    public static Singleton getInstance() {
        if (instance == null) { // 1. 第一次检查
            synchronized (Singleton.class) { // 2
                if (instance == null) { // 3. 第二次检查
                    instance = new Singleton(); // 4
                }
            }
        }
        return instance;
    }
}
````

1. 假设有两个线程 a 和 b 调用 getInstance() 方法，假设 a 先走，一路走到 4 这一步，执行 `instance = new Singleton()` 这句代码

2. instance = new Singleton() 这句代码首先会申请一段空间，然后将各个属性初始化为零值(0/null)，执行构造方法中的属性赋值[1]，将这个对象的引用赋值给 instance[2]。在这个过程中，[1] 和 [2] 可能会发生重排序

3. 此时，线程 b 刚刚进来执行到 1（看上面的代码块），就有可能会看到 instance 不为 null，然后线程 b 也就不会等待监视器锁，而是直接返回 instance
4. 问题是这个 instance 可能还没执行完构造方法（线程 a 此时还在 4 这一步），所以线程 b 拿到的 instance 是**不完整的**，它里面的属性值可能是初始化的零值（0/false/null），而不是线程 a 在构造方法中指定的值

> 如果线程 a 从 synchronized 块出来了，那么 instance 一定是**正确构造**的完整实例，这是 synchronized 的内存可见性保证



​		**<font color=green>解决重排序问题的可以使用volatile关键字修饰instance即可，因为volatile关键字能保证构造方法结束后，才将此对象引用赋值给 instance</font>**