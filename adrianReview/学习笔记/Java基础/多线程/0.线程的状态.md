### 线程的6种状态

1. <font color=blue>**初始（NEW）**</font>：新创建了一个线程对象，但还没有调用 `start()`方法

1. <font color=blue>**运行（RUNNABLE）**</font>：Java 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”

  > - 线程对象创建后，其他线程（比如main线程）调用了该对象的 `start()` 方法
  >
  > - 该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）
  >
  > - 就绪状态的线程在获得CPU时间片后变为运行中状态（running）

2. <font color=blue>**阻塞（BLOCKED）**</font>：表示线程阻塞于锁

3. <font color=blue>**等待（WAITING）**</font>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）

4. <font color=blue>**超时等待（TIMED_WAITING）**</font>：该状态不同于WAITING，它可以在指定的时间后自行返回

5. <font color=blue>**终止（TERMINATED）**</font>：表示该线程已经执行完毕

![线程状态的切换](.\images\线程状态.png)



### 状态详解

#### 初始状态

​		实现 `Runnable` 接口和继承 `Thread` 可以得到一个线程类，`new` 一个实例出来，线程就进入了初始状态

#### 就绪状态（运行）

1. 调用线程的 `start()` 方法，此线程进入就绪状态
2. 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态
3. 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态
4. 锁池里的线程拿到对象锁后，进入就绪状态

就绪状态就是：线程准备好，但是没有得到CPU的执行权的状态

#### 运行中（运行）

​		线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态



#### 阻塞状态

​		阻塞状态是线程阻塞在进入 `synchronized` 关键字修饰的方法或代码块（获取锁）时的状态



#### 等待

​		处于这种状态的线程不会被分配CPU执行时间，它们要**<font color=blue>等待被显式地唤醒</font>**，否则会处于无限期等待的状态

#### 超时等待

​		处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，<font color=blue>**在达到一定时间后它们会自动唤醒**</font>

比如调用 `Thread.sleep(1000)` 方法， `Thread.join(long millis)` 方法

#### 终止状态

1. 当线程的 `run()` 方法完成时，或者主线程的 `main()` 方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生

   > ​		在一个终止的线程上调用 `start()` 方法，会抛出 `java.lang.IllegalThreadStateException` 异常



### 线程几种方法小结

1. `Thread.sleep(long millis)`

   ​		一定是当前线程调用此方法，当前线程进入`TIMED_WAITING` 状态，但不释放对象锁，`millis`后线程自动苏醒进入就绪状态

2. `Thread.yield()`

   ​		一定是当前线程调用此方法，**当前线程放弃获取的CPU时间片**，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 `yield()` 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。`Thread.yield()` 不会导致阻塞。该方法与 `sleep()` 类似，只是不能由用户指定暂停多长时间

3. `Thread.join()` / `Thread.join(long millis)`

   ​		当前线程里调用其它线程t的 `join`方法，当前线程进入 `WAITING/TIMED_WAITING` 状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者 `millis` 时间到，当前线程一般情况下进入 `RUNNABLE` 状态，也有可能进入 `BLOCKED` 状态（因为join是基于wait实现的）

4. `obj.wait()`

   ​		当前线程调用对象的 `wait()` 方法，当前线程释放对象锁，进入等待队列。依靠`notify()` / `notifyAll()` 唤醒或者 `wait(long timeout)`  timeout 时间到自动唤醒。
   `obj.notify()` 唤醒在此对象监视器上等待的单个线程，选择是任意性的。`notifyAll()` 唤醒在此对象监视器上等待的所有线程

5. `LockSupport.park()` / `LockSupport.parkNanos(long nanos)` ，`LockSupport.parkUntil(long deadlines)`

   ​		 当前线程进入 `WAITING/TIMED_WAITING` 状态。对比wait方法,不需要获得锁就可以让线程进入 `WAITING/TIMED_WAITING` 状态，需要通过 `LockSupport.unpark(Thread thread)` 唤醒

