		**ReentrantLock、ReadLock、WriteLock** 是Lock接口最重要的三个实现类。对应了“可重入锁”、“读锁”和“写锁”

> `ReadWriteLock` 其实是一个工厂接口，而 `ReentrantReadWriteLock` 是`ReadWriteLock` 的实现类，它包含两个静态内部类 `ReadLock` 和 `WriteLock` 这两个静态内部类又分别实现了 `Lock` 接口



### Synchronized锁升级:偏向锁 → 轻量级锁 → 重量级锁

​		

​		`Synchronized` 会从**<font color=blue>无锁</font>**升级为**<font color=blue>偏向锁</font>**，再升级为**<font color=blue>轻量级锁</font>**，最后升级为**<font color=blue>重量级锁</font>**，这里的轻量级锁就是一种**<font color=blue>自旋锁</font>**

#### 偏向锁

​		初次执行到 `Synchronized` 代码块的时候，锁对象变成**<font color=red>偏向锁</font>**（通过CAS修改对象头里的锁标志位），字面意思是 ”偏向于第一个获得它的线程“ 的锁

​		执行完同步代码块后，线程并**不会主动释放偏向锁**。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。

​		**由于之前没有释放锁，这里也就不需要重新加锁。**如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高

​		**引入偏向锁的目的是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁在无竞争的情况下会把整个同步都消除掉**



#### 轻量级锁

​		一旦有第二个线程加入**<font color=red>锁竞争</font>**，偏向锁就升级为**<font color=red>轻量级锁（自旋锁）</font>**

​		**<u>这里要明确一下什么是锁竞争：</u>**如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争

​		在轻量级锁状态下继续锁竞争，没有抢到锁的线程将**<font color=red>自旋</font>**（即不停地循环判断锁是否能够被成功获取）

​		获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先**比较**当前锁标志位是否为“释放”，如果是则将其**设置**为“锁定”，比较并设置是**原子性**发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己

> ​		线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活
>
> - **如果线程A仍然存活，**将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋
> - 但是**如果判断结果是线程A不存在了**，则线程B持有此偏向锁，锁不升级



#### 忙等

​		长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做**<font color=red>忙等（busy-waiting）</font>**

​		如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么 `Synchronized` 就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，**短时间的忙等，换取线程在用户态和内核态之间切换的开销**



#### 重量级锁

​		显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）

​		如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为**<font color=red>重量级锁</font>**（依然是CAS修改锁标志位，但不修改持有锁的线程ID）

​		当后续线程尝试获取锁时，<font color=red>发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒</font>

> ​		在JDK1.6之前，`Synchronized` 直接加重量级锁，很明显现在得到了很好的优化



#### 锁消除

​		锁消除指的是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间

#### 锁粗化

​		原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁

​		大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗



### 小结

​		一个锁只能按照 <font color=green>**偏向锁、轻量级锁、重量级锁**</font> 的顺序逐渐升级（也有叫**锁膨胀**的），不允许降级



### 中断锁

​		Java并没有提供任何直接中断某线程的方法，只提供了**中断机制**

> 何谓“中断机制”？
>
> ​		线程A向线程B发出 “请你停止运行” 的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断
>
> ​		也就是说，Java的**中断不能直接终止线程**，而是需要被中断的线程自己决定怎么处理

​		如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是**可中断锁**。在Java中，synchronized就是**不可中断锁**，而Lock的实现类都是**可中断锁**