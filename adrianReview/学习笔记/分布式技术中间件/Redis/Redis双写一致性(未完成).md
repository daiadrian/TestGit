## Redis双写一致性

​		Redis和数据库的双写一致性也是指： 缓存 + 数据库 的读写模式

最经典的缓存+数据库读写的模式，就是 `Cache Aside Pattern`

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
- 更新的时候，**<font color=red>先更新数据库，然后再删除缓存</font>**

> **为什么是删除缓存，而不是更新缓存？**
>
> - 可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。这个时候去更新缓存，那么计算的代价是不能够接受的
> - 还有就是：**这个缓存到底会不会被频繁访问到**，不被频繁访问的缓存（也称为冷数据），更新缓存的意义也不大

### 双写一致性场景及解决方案

#### 简单的双写场景

场景：

- 先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致



解决方案：

- <font color=red>先删除缓存，再更新数据库</font>。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中



#### 高并发双写场景

场景：

- 数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改。此时数据库和缓存中的数据不一样了

  > **为什么上亿流量高并发场景下，缓存会出现这个问题？**
  >
  > ​		只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就**可能会出现上述的数据库+缓存不一致的情况**



解决方案：

