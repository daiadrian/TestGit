ElasticSearch

## 基本概念

### 正向索引

​	正向表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时<font color=red>**扫描表中每个文档**</font>中字的信息直到找出所有包含查询关键字的文档。

​	正向索引在建立索引的时候结构比较简单，建立比较方便且易于维护；因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在<font color=blue>**查询的时候需对所有的文档进行扫描**</font>以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。

> ​	最简单的例子，已知有5个文本文件，需要我们去查某个单词位于哪个文本文件中，最直观的做法就是挨个加载每个文本文件中的单词到内存中，然后用for循环遍历一遍数组，直到找到这个单词。这种做法就是正向索引的思路。

### 倒排索引

​	倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，**它记录该文档的ID和字符在该文档中出现的位置情况**。

​	由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率

> ​	倒排索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容，在搜索引擎的实际应用中，有时需要按照关键字的某些值查找记录，所以是按照关键字建立索引，这个索引就被称为倒排索引。
>
> ​	举个栗子：有一段文本，我们可以按照一定的<font color=red>分词规则</font>来对文本进行分词，然后将单词作为Hash表的key，将其所在本文的位置作为value进行保存，当我们要查询某个单词的所在位置时，只需要根据这张Hash表就可以迅速的找到目标文档。

### 集群(cluster)

1. 集群(cluster)是一组具有相同`cluster.name`的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。

2. 集群由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入集群的话，则该节点只能是集群的一部分。

3. 确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群

**【集群健康状态】**

> 集群状态通过 **绿**，**黄**，**红** 来标识
>
> - <font color=green>**绿色**</font> - 一切都很好（集群功能齐全）。
> - <font color=yellow>**黄色**</font> - 所有数据均可用，但尚未分配一些副本（集群功能齐全）。
> - <font color=red>**红色**</font> - 某些数据由于某种原因不可用（集群部分功能）。当群集为红色时，它将继续提供来自可用分片的搜索请求，但您可能需要尽快修复它，因为存在未分配的分片

### 节点(Node)

1. 节点，一个运行的 ES 实例就是一个节点，节点存储数据并参与集群的索引和搜索功能。

2. 就像集群一样，节点由名称标识，默认情况下，该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果不需要默认值，可以定义所需的任何节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中哪些服务器与 Elasticsearch 集群中的哪些节点相对应。

3. 可以将节点配置为按集群名称加入特定集群。默认情况下，每个节点都设置为加入一个名为 cluster 的 elasticsearch 集群，这意味着如果您在网络上启动了许多节点并且假设它们可以相互发现 - 它们将自动形成并加入一个名为 elasticsearch 的集群。

### 索引(Index)

1. 索引是具有某些类似特征的文档集合。例如，您可以拥有店铺数据的索引，商品的一个索引以及订单数据的一个索引。

2. 索引由名称标识（必须全部小写），此名称用于在对其中的文档执行索引，搜索，更新和删除操作时引用索引

> 类型，曾经是索引的逻辑类别/分区，允许您在同一索引中存储不同类型的文档，例如，一种类型用于用户，另一种类型用于博客帖子。
>
> - **索引（名词）** 一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方，index的复数是 indices 或 indexes
> - **索引（动词）** 「索引一个文档」表示把一个文档存储到索引（名词）里，以便它可以被检索或者查询。这很像SQL中的INSERT关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档
> - **倒排索引** 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做倒排索引(inverted index)的数据结构来达到相同目的

### 文档(Document)

​	文档是可以建立索引的基本信息单元。例如，您可以为单个客户提供文档，为单个产品提供一个文档，为单个订单提供一个文档。该文档以JSON表示。在索引/类型中，您可以根据需要存储任意数量的文档。请注意，尽管文档实际上驻留在索引中，但实际上必须将文档编入索引/分配给索引中的类型。

### 分片(Shards)

​	索引可能存储大量可能超过单个节点的硬件限制的数据。例如，占用1TB磁盘空间的十亿个文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独从单个节点提供搜索请求。

​	为了解决这个问题，Elasticsearch 提供了将索引细分为多个称为分片的功能。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。

设置分片的目的及原因主要是：

- 它允许您水平拆分/缩放内容量
- 它允许您跨分片（可能在多个节点上）分布和并行化操作，从而提高性能/吞吐量

​	分片的分布方式以及如何将其文档聚合回搜索请求的机制完全由 Elasticsearch 管理，对用户而言是透明的。在可能随时发生故障的网络/云环境中，分片非常有用，建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch 允许您将索引的分片的一个或多个副本制作成所谓的副本分片或简称副本。

### 副本(Replicasedit)

1. 副本，是对分片的复制。目的是为了当分片/节点发生故障时提供高可用性，它允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。

2. 每个索引可以拆分为多个分片。索引也可以复制为零次（表示没有副本）或更多次。复制之后，每个索引将具有主分片(从原始分片复制而来的)和复制分片(主分片的副本)。

3. 在创建索引时可以为每个索引定义分片和副本的数量。创建索引后，您也可以随时动态更改副本数。您可以使用`_shrink` 和 `_splitAPI` 更改现有索引的分片数，预先计划正确数量的分片是最佳方法。

### 小结

​	类比关系型数据库：Elasticsearch集群可以是包含多个索引(indices)（数据库），每一个索引可以包含多个类型 (Types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。

## 索引映射（Mapping）

### 字段类型

1. 字符串类型
   主要包括：text 和 keyword

   > ​	**text** 用于索引全文值的字段，例如电子邮件正文或产品说明。<font color=red>这些字段是analyzed，它们通过分词器传递 ，以在被索引之前将字符串转换为单个术语的列表</font>。分析过程允许Elasticsearch搜索单个单词中 每个完整的文本字段。文本字段不用于排序，很少用于聚合。
   >
   > ​	**keyword**用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。<font color=red>它们通常用于过滤，排序，和聚合。keyword字段只能按其确切值进行搜索。</font>
   >
   > ​	有时候一个字段同时拥有全文类型（text）和关键字类型（keyword）是有用的：一个用于全文搜索，另一个用于聚合和排序。这可以通过**多字段**类型来实现
   >
   > （对于字符串字段，我们既可以将它映射为text类型用于全文搜索，亦可以将它映射为keyword类型用于排序或聚合，或者，还可以使用标准分词器、英语分词器和其他语言分词器索引文本字段）
   >
   > ````json
   > //多字段的映射
   > {
   >   "mappings": {
   >     "_doc": {
   >       "properties": {
   >         "cityName": {
   >           "type": "text",
   >           "fields": {
   >             "raw": { 
   >               "type":  "keyword"
   >             }
   >           }
   >         }
   >       }
   >     }
   >   }
   > }
   > ````

2. 数字类型
   主要包括：long, integer, short, byte, double, float, half_float, scaled_float

3. 日期类型：date

4. 布尔类型：boolean

5. 二进制类型

6. 范围数据类型
   integer_range, float_range, long_range, double_range, date_range

7. 复杂数据类型

- [数组数据类型](https://www.elastic.co/guide/en/elasticsearch/reference/6.5/array.html)
- [对象数据类型](https://www.elastic.co/guide/en/elasticsearch/reference/6.5/object.html)
- [嵌套数据类型（Nested datatype）](https://www.elastic.co/guide/en/elasticsearch/reference/6.5/nested.html)

8. Geo数据类型

- [地理点数据类型](https://www.elastic.co/guide/en/elasticsearch/reference/6.5/geo-point.html)
  geo_point 对于纬度/经度点
- [Geo-Shape数据类型](https://www.elastic.co/guide/en/elasticsearch/reference/6.5/geo-shape.html)
  geo_shape 对于像多边形这样的复杂形状

### 映射

**映射**是定义一个文档及其包含的字段如何存储和索引的过程。例如，使用映射来定义：

- 应将哪些字符串字段视为全文字段
- 哪些字段包含数字，日期或地理位置
- 是否应将文档中所有字段的值索引到catch-all _all字段中
- 日期值的格式
- 自定义规则以控制动态添加字段的映射

#### 动态映射

​	不事先指定映射类型(Mapping)，文档写入ElasticSearch时，ES会根据文档字段自动识别类型，这种机制称之为动态映射

#### 静态映射

​	人为事先定义好映射，包含文档的各个字段及其类型等，这种方式称之为静态映射，亦可称为显式映射

#### 利用别名做数据迁移和改动字段类型

> ​	在 Elasticsearch 中尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是**<font color=red>不能添加新的分析器或者对现有的字段做改动</font>**。如果你那么做的话，结果就是那些已经被索引的数据就不正确，搜索也不能正常工作。
>
> ​	假设我们有个学生的原始索引 student_index_v1，我们给它起个别名 student_index，程序中也是用别名 student_index 进行搜索，当我们的业务需求发生改变需要**修改索引**的时候，我们重新创建个索引 student_index_v2，同时将别名 student_index 指向新的索引 student_index_v2，同时将 student_index_v1 的数据迁移到新的 student_index_v2，这样我们就可以做到在零停机下从旧索引切换到新索引；具体操作：
>
> ````json
> //创建索引student_index_v1
> //创建索引student_index_v2
> 
> //设置别名 student_index 指向 student_index_v1
> PUT /student_index_v1/_alias/student_index  
> 
> //将别名 student_index 指向新的索引 student_index_v2
> POST /_aliases
> {
>     "actions": [
>         { "remove": { "index": "student_index_v1", "alias": "student_index" }},
>         { "add":    { "index": "student_index_v2", "alias": "student_index" }}
>     ]
> }
> //为了有效的重新索引所有在旧的索引中的文档，可以用 scroll 从旧的索引检索批量文档，然后用 bulk API 把文档推送到新的索引中
> ````

#### 路由

​	当索引一个文档的时候，文档会被存储到一个主分片中；我们可以在创建文档的时候指定这个文档应该路由到哪个分片中。

​	ES默认的路由规则公式是：`shard = hash(routing) % number_of_primary_shards` 

> ​	`routing` 是一个可变值，默认是文档的 `_id` ，也可以设置成一个自定义的值。 `routing` 通过 hash 函数生成一个数字，然后这个数字再除以 `number_of_primary_shards` （主分片的数量）后得到 **余数** 。这个分布在 `0` 到 `number_of_primary_shards-1` 之间的余数，就是我们所寻求的文档所在分片的位置。
>
> ​	这就是为什么要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了



