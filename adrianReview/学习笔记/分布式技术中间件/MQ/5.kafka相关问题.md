### kafka高可用

​		Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据（有HA机制后，每个 broker 都有分区上的完整数据），这就是**天然的分布式消息队列**



HA机制（`hight availablity` 高可用），kafka 的副本机制（`replica`）：

​		每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。

​		写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。<font color=red>**Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性**</font>

> 为什么只能读写 leader？很简单，**要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题**，系统复杂度太高，很容易出问题

​		如果某个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中**重新选举**一个新的 leader 出来，然后继续读写那个新的 leader 即可。这就有所谓的高可用性了

​		<font color=blue>**写数据**的时候，生产者只写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据</font>。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，**<font color=red>leader 收到所有 follower 的 ack 之后</font>**，就会返回写成功的消息给生产者。（这只是其中一种模式，还可以适当调整这个行为）

​		<font color=blue>**消费**的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到</font>



### kafka丢数据问题

#### 消费端丢失数据

​		唯一可能导致消费者弄丢数据的情况就是：你消费到了这个消息，然后消费者那边**自动提交了 offset**，让 Kafka 以为你已经消费好了这个消息，但其实还没处理这个消息，消费者就挂了，此时这条消息就丢失了

​		这种情况是由于kafka自动提交offset导致的，那么只要**关闭自动提交** offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是**可能会有重复消费**，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了



#### kafka弄丢数据

​		Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，这就丢了一些数据

此时一般是要求起码设置如下 4 个参数：

- 给 topic 设置 `replication.factor` 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。
- 在 Kafka 服务端设置 `min.insync.replicas` 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。
- 在 producer 端设置 `acks=all`：这个是要求每条数据，必须是**写入所有 replica 之后，才能认为是写成功了**。
- 在 producer 端设置 `retries=MAX`（很大很大很大的一个值，无限次重试的意思）：这个是**要求一旦写入失败，就无限重试**，卡在这里了。

​		生产环境按照上述要求配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失



#### 生产者弄丢数据

​		设置了 `acks=all`，一定不会丢，要求是： leader 接收到消息，**所有的 follower 都同步到了消息之后**，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次