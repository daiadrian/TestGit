MQ 消息队列相关问题及其解决方案



### MQ发送重复数据

#### 导致MQ发送重复数据的原因

​		造成消息重复的根本原因是：<font color=red>**网络不可达**</font>；<font color=blue>（由于网络各种原因，消费者端的确认消息没及时到达到MQ服务器，所以MQ服务器会重新发送消息，导致数据重复发送）</font>

​		只要通过网络交换数据，就无法避免这个问题

#### 解决方案

1. **消费端** 处理消息的业务逻辑 <font color=red>**保持幂等性**</font>

   > ​		保证系统的幂等性，即无论重复消息发多少次，对应的数据不能发生改变（只有第一次的消费成功更新数据，其他的重复消费不会对数据产生影响）
   >
   > 这种解决方式需要<font color=blue>结合业务</font>进行，如：
   >
   > - 消费的数据要写库，可以先根据主键查一下，如果这数据都有了，那么就update 一下即可
   > - 如果只是 set 缓存（Redis）的话，那么就是天然的幂等性
   > - 可以基于数据库的唯一键（主键或者唯一索引 unique key）来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据

2. 保证每条消息都有**唯一编号**且保证消息处理成功与去重表的日志同时出现

   > ​		利用一张**<font color=blue>消息处理日志表</font>**来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息



### MQ消息丢失

#### RabbitMQ

##### 消息丢失原因

1. 生产者弄丢了数据

   > ​		生产者将数据发送到 RabbitMQ 的时候，可能数据就在网络传输途中给搞丢了，因为网络问题啥的，都有可能

2. RabbitMQ 弄丢了数据

   > ​		RabbitMQ 收到消息之后，会暂存在内存中，还没被消费者消费的时候，服务挂掉了，内存中的数据就会丢失掉了

3. 消费者弄丢数据

   > 主要是消费者消费的时候，还没处理完就发生 重启/挂掉 的情况；那么数据就会丢失了
   >
   > 或者消费者消费的时候，出现了异常等情况，也会导致数据丢失



##### 解决方案

1. 生产者弄丢数据时

   - 方案一：选择RabbitMQ 的事务机制

     >  		生产者**发送数据之前**开启 RabbitMQ 事务`channel.txSelect`，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务`channel.txRollback`，然后重试发送消息；如果收到了消息，那么可以提交事务`channel.txCommit`。伪代码：
     >
     > ```java
     > // 开启事务
     > channel.txSelect
     > try {
     >     // 这里发送消息
     > } catch (Exception e) {
     >     channel.txRollback
     >     // 这里再次重发这条消息
     > }
     > // 提交事务
     > channel.txCommit
     > ```
     >
     > ​		RabbitMQ 事务机制（同步）一搞，基本上**<font color=red>吞吐量会下来，因为太耗性能</font>**

   - 方案二：

     > ​		可以开启 `confirm` 模式，在生产者那里设置开启 `confirm` 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 `ack` 消息，告诉你说这个消息 ok 了
     >
     > ​		如果 RabbitMQ 没能处理这个消息，会回调你的一个 `nack` 接口，告诉你这个消息接收失败，你可以重试
     >
     > ​		而且可以结合这个机制自己在内存里维护每个消息 ID 的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发消息

   - 两种方案的比较：

     > ​		事务机制和 `confirm` 机制最大的不同在于，**事务机制是同步的**，你提交一个事务之后会**阻塞**在那儿，但是 `confirm` 机制是**异步**的，你发送个消息之后就可以发送下一个消息，然后消息被 RabbitMQ 接收了之后会异步回调 `nack` 接口通知你这个消息接收到了
     >
     > ​		所以一般在生产者这块**避免数据丢失**，都是用 `confirm` 机制的

     

2. RabbitMQ 弄丢了数据时

   解决方案： **<font color=red>开启 RabbitMQ 的持久化</font>**

   > ​		消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 挂了，**恢复之后会自动读取之前存储的数据**，一般数据不会丢失
   >
   > ​		除非RabbitMQ 还没持久化，自己就挂了，**可能导致少量数据丢失**，但是这个概率较小

   设置持久化有**两个步骤**：

   - 创建 queue 的时候将其设置为持久化。这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的

   - 第二个是发送消息的时候将消息的 `deliveryMode` 设置为 2，就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。

     > ​		必须要同时设置这两个持久化才行，即使RabbitMQ 挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据

   ​         **注意：** <u>哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，然后此时 RabbitMQ 挂了，就会导致内存里的数据丢失</u>

   ​		<font color=green>所以持久化可以跟生产者那边的 `confirm` 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 `ack`了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 `ack`，也是可以重发消息的</font>

   

3. 消费端弄丢了数据

   解决方案：

   > ​		需要用 RabbitMQ 提供的 `ack` 机制，简单来说：
   >
   > - 就是**必须关闭 RabbitMQ 的自动 `ack`**
   > - 然后可以通过一个 API 来调用 `ack`，即每次自己的代码里确保处理完数据的时候，再在程序里 `ack` 
   > - 这样的话，如果你还没处理完，不就没有 `ack` 了？那么 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的（这里如果MQ方的超时时间的过小容易导致上面的数据重发问题）

