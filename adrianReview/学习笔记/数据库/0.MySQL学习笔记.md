MySQL_InnoDB存储引擎笔记

## 数据库基础概念

**数据库**：物理操作系统的文件或者其他形式文件类型的集合。当使用NDB引擎时，数据库的文件可能不是操作系统上的文件，而是内存中的文件。

**实例**（instance）：MySQL数据库由后台线程以及一个共享内存区组成；共享内存可以被运行的后台线程所共享。数据库实例是用于操作数据库文件的。数据库的实例在操作系统中就是表现为一个进程



### DDL和DML

​		DML（data manipulation language）数据操纵语言：SELECT、UPDATE、INSERT、DELETE

​		DDL（data definition language）数据库定义语言：即创建表的时候用到的一些SQL，比如说：CREATE、ALTER、DROP等。DDL主要是用在 定义或改变表的结构、数据类型、表之间的链接和约束等初始化工作上



### 数据库三大范式

1. **第一范式**：每一列属性都是不可再分的属性值，保证每一列的原子性

2. **第二范式**：满足第一范式的情况下，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情

   > 例如：
   >
   > - 订单表只描述订单相关的信息，所以所有字段都必须与订单id相关
   >
   > - 产品表只描述产品相关的信息，所以所有字段都必须与产品id相关
   >
   > 因此不能在一张表中同时出现订单信息与产品信息

3. **第三范式**：满足第二范式的情况下，要求表中的每一列只与主键**直接相关**而不是间接相关（表中的每一列只能依赖于主键）

   > 例如：
   >
   > ​		订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户id即可（外键），而不能有其他的客户信息
   >
   > ​		因为其他的客户信息直接关联于用户id，而不是直接与订单id直接相关



### 数据库事务

​		事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务

​		<font color=red>**数据库事务指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚**</font>

> ​		当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行
>
> ​		但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。
>
> ​		这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作



#### 事务的特性

事务具有4个特性：原子性、一致性、隔离性和持久性

1. **原子性（atomicity）**：一个事务包含的操作是不可分割的，要么全部执行成功，要么全部失败回滚

2. **一致性（consistency）**：事务必须是使数据库从一个一致性状态到另一个一致性的状态。

   >  	因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态

3. **隔离性（isolation）**：一个事务的执行不能被其他事务干扰；即一个事务内的操作及其使用的数据对并发的其他事务操作是隔离的，互不干扰的

4. **持久性（durability）**：一个事务一旦提交，那么它对数据库的改变是永久的。接下来的其它操作或故障不应该对其执行结果有任何影响



事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
- 事务满足持久化是为了能应对数据库崩溃的情况



#### 隔离级别

​		SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定**事务内外的哪些改变是可见的，哪些是不可见的**。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销

````mysql
-- 均为mysql
-- 查看隔离级别
SELECT @@tx_isolation
-- 设置隔离级别
--  read uncommitted:  读取尚未提交的数据：哪个问题都不能解决
--  read committed：   读取已经提交的数据：可以解决脏读
--  repeatable read：  重读读取：可以解决脏读和不可重复读  --> mysql默认的
--  serializable：     串行化 --> 相当于锁表
set session transaction isolation level [事务隔离级别]
````

1. **Read Uncommitted（读取未提交内容）**

   - 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果

   - 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少

   - 读取未提交的数据，也被称之为**<font color=red>脏读</font>**（Dirty Read）

     > ​		A用户修改了数据（存100块，账户为100），随后B用户又读出该数据（100）；但A用户因为某些原因取消了对数据的修改，数据恢复原值（账户0）
     >
     > ​		此时B得到的数据为100就与数据库内的账户为0数据不一样

2. **Read Committed（读取提交内容）**

   - 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）

   - 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变（即个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的）

   - 这种隔离级别也叫做**<font color=red>不可重复读</font>**（Nonrepeatable Read），因为两次执行同样的查询，可能会得到不一样的结果

     > A用户读取了数据100，随后B用户读出该数据并修改（加了100），此时A用户再读取数据时发现前后两次的值不一致

3. **Repeatable Read（可重读）**

   - 是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行

   - 不过会导致另一个棘手的问题：**<font color=red>幻读</font>**（Phantom Read）：幻读指当A用户读取某一范围的数据行时，B用户又在该范围内插入了新行，当A用户提交本次事务之后，再次查询会发现在这个范围的数据又多出了一行新数据，就好像幻觉一样

     > 简单来说就是两次范围查询的数据行不一致（因为期间有人插入新数据）

   - InnoDB存储引擎通过多版本并发控制（MVCC）机制解决了不可重复读的问题

4. **Serializable（可串行化）**

   - 这是最高的隔离级别，它通过强制事务排序执行（即**串行化的执行多个事务**），使之不可能相互冲突，从而解决幻读问题
   - 它是在每个读的**数据行**上加上锁。在这个级别，可能导致大量的超时现象和锁竞争
   - 只有在非常需要确保数据的一致性而且可以接受没有并发的情况，才可考虑用该级别



#### MVCC（多版本并发控制）

​		MVCC即Multi-Version Concurrency Control，多版本并发控制。最早的数据库系统，只有读读之间可以并发。读写，写读，写写都要阻塞。引入多版本并发控制之后，<font color=green>**只有写写之间相互阻塞，其他三种操作都可以并行**</font>，这样大幅度提高了InnoDB的并发度

​		可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作， 因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC的实现方式有多种，典型的有<font color=blue>乐观并发控制</font>（optimistic）和<font color=blue>悲观并发控制</font>（pessimistic）；InnoDB的MVCC是通过在每行记录后面保存**三个隐藏的列**来实现的

> 1. DB_TRX_ID：6个字节，插入或更新行的最后一个事务的事务标识符
> 2. DB_ROLL_PTR：7个字节，写入回滚段的撤消日志记录
> 3. DB_ROW_ID：6个字节，行标识

​		MVCC只在 `READ COMMITTED`（读提交） 和 `REPEATABLE READ` （可重复读）两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为 `READ UNCOMMITTED` 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 `SERIALIZABLE` 则会对所有读取的行都加锁



### 外键

​		**可以使得两张表关联，保证数据的一致性和实现一些级联操作**。保持数据一致性，完整性，主要目的是控制存储在外键表中的数据。使两张表形成关联，外键只能引用外表中的列的值

#### 使用外键的一些问题

1. 数据库需要维护外键的内部管理
2. 有了外键，当做一些涉及外键字段的增删改操作之后，需要触发相关操作去检查而不得不消耗资源



## SQL语句注意事项	

### SQL语句执行顺序

sql执行顺序

1. from

   > 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1

2. on

   > 对虚表VT1进行ON筛选，只有那些符合`join-condition`的行才会被记录在虚表VT2中

3. join

   > ​		如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3，外连接子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止

4. where

   > ​		对虚拟表VT3进行WHERE条件过滤。只有符合`where-condition`的记录才会被插入到虚拟表VT4中

5. group by

   > ​	根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5

6. avg，sum....

   > 对VT5进行各项函数操作得到VT6

7. having

   > 对虚拟表VT6应用having过滤，只有符合`having-condition`的记录才会被 插入到虚拟表VT7中

8. select

   > 执行select操作，选择指定的列，插入到虚拟表VT8中

9. distinct

   > 对VT8中的记录进行去重。产生虚拟表VT9

10. order by

    > 将虚拟表VT9中的记录按照`order_by_list`进行排序操作，产生虚拟表VT10

11. LIMIT

    > 取出指定行的记录，产生虚拟表VT11, 并将结果返回



### Char和VarChar的区别

1. char是固定长度，varchar长度可变

   varchar：如果原先存储的位置无法满足其存储的需求，就需要一些额外的操作，根据存储引擎的不同，有的会采用拆分机制，有的采用分页机制

   

2. char的存储方式是：英文字符占1个字节，汉字占用2个字节

   varchar的存储方式是：英文和汉字都占用2个字节，两者的存储数据都非unicode的字符数据

   

3. char是固定长度，长度不够的情况下，用空格代替

   varchar表示的是实际长度的数据类型
   
   

选用考量：如果字段长度较短和字符间长度相近甚至是相同的长度，会采用char字符类型；否则选用varchar



### Delete、truncate和drop的区别

1.  在速度上，一般来说，drop> truncate > delete
2. 数据删除：
   - 使用delete删除
     - DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存，以便进行进行回滚操作；同时在删除过程会触发与表有关的删除触发器
     - DELETE操作不会减少表或索引所占用的空间
   - 使用drop删除
     - drop语句将表所占用的空间全释放掉
   - 使用truncate删除
     - 当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小
     -  TRUNCATE TABLE会一次性地从表中删除所有的数据，删除行是不能被恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快



## 存储引擎

### Innodb

​		Innodb是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

​		它实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

​		主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

​		支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取

### MyISAM

​		设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。提供了大量的特性，包括压缩表、空间数据索引等。

​		不支持事务。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

​		可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

​		如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作

### 两者的比较

- **事务**：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- **并发**：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- **外键**：InnoDB 支持外键。
- **备份**：InnoDB 支持在线热备份。
- **崩溃恢复**：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- **其它特性**：MyISAM 支持压缩表和空间数据索引



