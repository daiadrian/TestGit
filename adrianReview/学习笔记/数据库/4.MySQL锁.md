## MySQL 锁

数据库在执行SQL语句时会隐式的加锁：

- 对于 `UPDATE、DELETE、INSERT` 语句，InnoDB会自动给涉及数据集加**排他锁**（X)
- MyISAM在执行查询语句 `SELECT` 前，会自动给涉及的所有表加**读锁**（表锁），在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会自动给涉及的表加**写锁**，这个过程并不需要用户干预

使用者只需要在特定的场景上才需要**手动加锁**



​		MySQL 中提供了两种封锁粒度：**行级锁以及表级锁**

​		应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**<font color=red>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高</font>**

​		但是**加锁需要消耗资源**，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大

​		所以在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡



### 锁粒度区别

1. 表锁

   > 表锁偏向 MyISAM 存储引擎，开销小，加锁快，无死锁
   >
   > 但是锁的粒度大，发生冲突的几率较高，并发度最低

2. 行锁

   > 偏向 InnoDB 存储引擎，开销大，加锁慢，会发生死锁
   >
   > 但是锁的粒度最小，发生锁冲突的概率较低，并发度最高



​		InnoDB存储引擎同时支持行表锁；<font color=red>InnoDB只有通过索引条件检索数据才使用行级锁</font>，否则InnoDB将使用**表锁**。也就是说，**InnoDB的行锁是基于索引的**。



#### 读写锁

- 排它锁（Exclusive），又称写锁
- 共享锁（Shared），又称读锁

有以下两个规定：

- 一个事务对数据对象 A 加了写锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁
- 一个事务对数据对象 A 加了 读锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 读锁，但是不能加写锁



### 表锁

**表锁下又分为两种模式**：

- 表读锁（Table Read Lock）
- 表写锁（Table Write Lock）
  - 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
  - 读写阻塞：当前用户在读数据，其他的用户**不能修改当前用户读的数据**，会加锁！
  - 写写阻塞：当前用户在修改数据，其他的用户**不能修改当前用户正在修改的数据**，会加锁



**<font color=red>读锁和写锁是互斥的，读写操作是串行</font>**

- 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，**写锁是优先于读锁的**！
- 写锁和读锁优先级的问题是可以通过参数调节的：`max_write_lock_count`和`low-priority-updates`

> 注意：
>
> ​		`MyISAM`可以支持查询和插入操作的**并发**进行。可以通过系统变量`concurrent_insert`来指定哪种模式，在`MyISAM` 中它默认是：如果 `MyISAM` 表中没有空洞（即表的中间没有被删除的行），`MyISAM`允许在一个进程读表的同时，另一个进程从**表尾**插入记录。
>
> 但是**InnoDB存储引擎是不支持的**



### 行锁

InnoDB实现了以下两种类型的行锁：

- 共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 
  - 也叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。
- 排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 
  - 也叫做**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**



另外，**为了允许行锁和表锁共存，实现多粒度锁机制**，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**：

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS锁
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX锁
- 意向锁也是数据库隐式的加上了

