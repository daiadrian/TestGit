### limit存在的问题及其优化

例子：在一个百万级别的数据表中，查询id是200 w的及其后20条数据，对应SQL为：

`select * from table limit 2000000,20;`

​		此时 limit 会查出前 2000020 条数据，然后丢弃掉前 2000000 条数据后返回，这个时候就会变得非常慢；换句话说当一个数据库表过于庞大，`LIMIT offset, length` 中的offset值过大，则SQL查询语句会非常缓慢

> `limit offset, length` 这个操作MySQL 是不知道从哪里开始，是需要从头开始扫描，直到符合limit的位置之后再返回数据
>
> 注意：limit 在SQL语句的执行顺序中是最后执行的

#### 优化方案

1. 子查询优化方案

   - 该方案必须是有序的数据，按照ID有序或者某一字段有序的数据集才能使用该方案

   - ```mysql
     select * from myTable 
     where ID >= (select ID from myTable limit 10000,1) limit 100;
     #limit 100 的写法默认偏移量 offset=0
     # 这条SQL查询了 limit 10000,100 的数据
     ```

   - 主要的原因是，子查询使用了覆盖索引，所以查询的效率很快



### MyISAM和Innodb的区别

- <font color=blue>InnoDB支持事务</font>，而MyISAM不支持事物
- <font color=blue>InnoDB支持行级锁</font>，而MyISAM支持表级锁
- InnoDB支持MVCC, 而MyISAM不支持
- <font color=blue>InnoDB支持外键</font>，而MyISAM不支持
- InnoDB不支持全文索引，而MyISAM支持



**select count(*)** 是MyISAM查询更快，因为MyISAM内部维护了一个计数器，可以直接返回