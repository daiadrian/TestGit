### SnowFlake算法理解位数运算

#### 负数的二进制表示

在计算机中，负数的二进制是用`补码`来表示的。
假设我是用Java中的int类型来存储数字的，
int类型的大小是32个二进制位（bit），即4个字节（byte）。（1 byte = 8 bit）
那么十进制数字`3`在二进制中的表示应该是这样的：

```
00000000 00000000 00000000 00000011  //3的二进制表示，就是原码
```

那数字`-3`在二进制中应该如何表示？
我们可以反过来想想，因为-3+3=0，
在二进制运算中，把-3的二进制看成未知数x来求解，
求解算式的二进制表示如下：

```
   00000000 00000000 00000000 00000011 //3，原码
+  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx //-3，补码
-----------------------------------------------
   00000000 00000000 00000000 00000000
```

反推x的值，3的二进制加上什么值才使结果变成`00000000 00000000 00000000 00000000`？：

```
   00000000 00000000 00000000 00000011 //3，原码                         
+  11111111 11111111 11111111 11111101 //-3，补码
-----------------------------------------------
 1 00000000 00000000 00000000 00000000
```

反推的思路是3的二进制数从最低位开始逐位加1，使溢出的1不断向高位溢出，直到溢出到第33位。然后由于int类型最多只能保存32个二进制位，所以最高位的1溢出了，剩下的32位就成了（十进制的）0。

**补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个“溢出的0”**

以上是理解的过程，实际中记住**公式**就很容易算出来：

- 补码 = 反码 + 1
- 补码 = （原码 - 1）再取反码

因此`-1`的二进制应该这样算：

```
00000000 00000000 00000000 00000001 //原码：1的二进制
11111111 11111111 11111111 11111110 //取反码：1的二进制的反码
11111111 11111111 11111111 11111111 //加1：-1的二进制表示（补码）
```

#### 用位运算计算n个bit能表示的最大数值

比如这样一行代码：

```
    private long workerIdBits = 5L;
    private long maxWorkerId = -1L ^ (-1L << workerIdBits);       
```

上面代码换成这样看方便一点：
`long maxWorkerId = -1L ^ (-1L << 5L)`

咋一看真的看不准哪个部分先计算，于是查了一下Java运算符的优先级表:
![图片描述](https://segmentfault.com/img/bVVt9g?w=400&h=373)

所以上面那行代码中，运行顺序是：

- -1 左移 5，得结果a
- -1 异或 a

`long maxWorkerId = -1L ^ (-1L << 5L)`的二进制运算过程如下：

**-1 左移 5，得结果a ：**

```
        11111111 11111111 11111111 11111111 //-1的二进制表示（补码）
  11111 11111111 11111111 11111111 11100000 //高位溢出的不要，低位补0
        11111111 11111111 11111111 11100000 //结果a
```

**-1 异或 a ：**

```
        11111111 11111111 11111111 11111111 //-1的二进制表示（补码）
    ^   11111111 11111111 11111111 11100000 //两个操作数的位中，相同则为0，不同则为1
---------------------------------------------------------------------------
        00000000 00000000 00000000 00011111 //最终结果31
```

最终结果是31，二进制`00000000 00000000 00000000 00011111`转十进制可以这么算：

2^4+2^3+2^2+2^1+20=16+8+4+2+1=31

​	那既然现在知道算出来`long maxWorkerId = -1L ^ (-1L << 5L)`中的`maxWorkerId = 31`，有什么含义？为什么要用左移5来算？

> `5位（bit）`可以表示的最大正整数是$2^{5}-1 = 31$，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId

​	-1L ^ (-1L << 5L)`结果是`31`，$2^{5}-1$的结果也是`31`，所以在代码中，`-1L ^ (-1L << 5L)`的写法是`利用位运算计算出5位能表示的最大正整数是多少



### 进制的基础

![](C:\Adrian\学习笔记\计算机基础\images\1.二进制转十进制.png)

![](C:\Adrian\学习笔记\计算机基础\images\1.十进制转二进制.png)

![](C:\Adrian\学习笔记\计算机基础\images\1.其他进制.png)





### 二进制的位运算

![](C:\Adrian\学习笔记\计算机基础\images\1.二进制的位运算.png)



#### 与运算

![](C:\Adrian\学习笔记\计算机基础\images\1.二进制与运算.png)

3. 判断一个数是否为偶数，偶数的最后一位为 0 ，奇数的最后一位是 1 ； 

   > `if((a & 1) == 0)` 即可判断数值 a 是否是偶数了。因为任何数 & 0 都是0
   >
   > 1 的二进制只有最后一位是1 ，左边的所有位都为0



#### 或运算

![](C:\Adrian\学习笔记\计算机基础\images\1.二进制的或运算.png)





#### 异或运算

![](C:\Adrian\学习笔记\计算机基础\images\1.二进制异或运算.png)



**异或运算：交换两个值**

交换A和B的值

- A = A^B;    B = A ^ B;   A = A ^ B;  这样就可以交换 A 和 B 的值了

> 解释：（<font color=red>**一个数 “异或” 本身时等于0，因为值相同时位结果为0**</font>）
>
> - A=A^B;
> - B = A ^ B    = (A ^ B) ^ B     = A ^ (B ^ B)     = A ^ 0 = A;
> - A = A ^ B    = (A ^ B) ^ A     = (A ^ A) ^ B     = 0 ^ B = B;





### 补码

负数在计算机中都是以补码的形式存储

负数转补码的步骤：

1. 除符号位外，全部取反
2. 然后最后一位加 1  即可得到补码 

> 【例1】求-5的补码。
>
> -5对应正数5（00000101）→所有位取反（11111010）→加1(11111011)
>
> 所以-5的补码是11111011。
>
> 【例2】数0的补码表示是**唯一**的。
>
> [+0] 补=[+0]反=[+0]原=00000000
>
> [ -0] 补=11111111+1=00000000

### 无符号数

无符号数指整个机器<font color=blue>字长的全部二进制位</font>均表示数值位，**相当于数的绝对值**

> 带符号数：最高位被用来表示符号位，而不再表示数值位
>
> （例如：1111 是-7；而无符号数 1111 是15）