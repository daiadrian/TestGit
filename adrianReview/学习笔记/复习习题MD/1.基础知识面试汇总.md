### 基本数据类型的比较

````java
Integer i01 = 59;
int i02 = 59;
Integer i03 =Integer.valueOf(59);
Integer i04 = new Integer(59);
````

i02为基本数据类型，有<font color=red>**基本数据类型的都是比较值**</font>

（所以 `i02 == i04` 返回的是 true）



​		JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象

### Switch关键字

<font color=green>**switch语句后的控制表达式只能是：**</font>

- short
- char
- int
- long整数类型
- 枚举类型
- **String类型是java7开始支持**

> ​		在 `switch(expr1)` 中，expr1只能是一个**整数表达式或者枚举常量（更大字体）**，整数表达式可以是int基本类型或Integer包装类型
>
> ​		由于<font color=blue>**byte、short、char都可以隐含转换为int**</font>，所以这些类型以及这些类型的包装类型也是可以的

<font color=red>**不能是：**</font>

- float
- double
- boolean类型

### Java反射

每个类都有一个 **Class** 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 `.class` 文件，该文件内容保存着 Class 对象。

​		类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 Class 对象

​		反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 `.class` 不存在也可以加载进来。

Class 和 `java.lang.reflect` 一起对反射提供了支持，`java.lang.reflect` 类库主要包含了以下三个类：

- **Field** ：可以使用 `get()` 和 `set()` 方法读取和修改 Field 对象关联的字段；
- **Method** ：可以使用 `invoke()` 方法调用与 Method 对象关联的方法；
- **Constructor** ：可以用 Constructor 的 `newInstance()` 创建新的对象



#### 优点

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率

#### 缺点

​		尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用

在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化



### Java泛型

在Java1.4及其之前的版本中，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。

​		泛型提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现 `ClassCastException`

​		**泛型是通过类型擦除来实现的**，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 `List<String>` 在运行时仅用一个List来表示。这样做的目的，是确保能和 Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型

#### 限定通配符和非限定通配符

1. 限定通配符
   - <? extends T>  它通过确保类型必须是  **T的子类**  来设定类型的 **上界**
   - <? super T>  它通过确保类型必须是  **T的父类**  来设定类型的 **下界**
2. 非限定通配符
   - `<?>` 表示了非限定通配符，因为 `<?>` 可以用任意类型来替代



### finally 块

​		一旦在finally块中使用了 `return` 或 `throw` 语句，将会**导致try块，catch块中的 `return` ，`throw` 语句失效



### 抽象和接口

#### abstract 抽象类

抽象类的一些特性：

1. abstract类不能与 `final`，`static` 使用。final 修饰方法，子类可以调用，但不能覆盖（即不能被重写）
2. 抽象类中可以有非抽象方法
3. 抽象类中可以都是非抽象的，但是<font color=red>抽象方法一定要在**抽象类和接口**中</font>

#### interface接口

​		接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为`public abstract`类型，<font color=blue>接口中的成员变量类型默认为`public static final`</font>

​		从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类

​		接口的成员（字段 + 方法）**默认都是 `public` 的**，并且不允许定义为 `private` 或者 `protected` ；接口的字段默认都是 `static final` 的

​		**Java8之后开始支持接口中定义静态方法**

```java
public interface InterfaceExample {
    void func1();
    default void func2(){
        System.out.println("func2");
    }
    int x = 123;
    public int z = 0;
    static void func3(){
        System.out.println("func3");
    }
}
```



#### 抽象和接口的区别

1. 抽象类可以有构造方法

   接口中不能有构造方法  

2. 抽象类中可以包含非抽象的普通方法

   接口中的所有方法必须都是抽象的，不能有非抽象的普通方法

3. 抽象类中可以有普通成员变量

   接口中没有普通成员变量，接口的成员变量必须是`public static final`的

4. 抽象类中的抽象方法的访问类型可以是public，protected和default类型

   接口的方法有public和default（JDK8以后支持default）

5. 抽象类中可以包含静态方法

   接口中不能包含静态方法

6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是`public static final`类型

7. 一个类可以实现多个接口，但只能继承一个抽象类

   >  二者在应用方面也有一定的区别：
   >
   > - 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约
   >
   > - 抽象类在代码实现方面发挥作用，可以实现代码的重用
   >
   >   > 例如：模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。

#### super 关键字

- <font color=blue>访问父类的构造函数：</font>可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作
- <font color=blue>访问父类的成员方法：</font>如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现

```java
public class SuperExtendExample extends SuperExample {
    private int z;
    public SuperExtendExample(int x, int y, int z) {
        //使用父类的构造器完成一些初始方法
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        //使用父类的成员方法做一些事情
        super.func();
        System.out.println("SuperExtendExample.func()");
    }
}
```



### 访问控制修饰符

|                    | private | default | protected | public |
| :----------------: | :-----: | :-----: | :-------: | :----: |
|     同一个类中     |    √    |    √    |     √     |   √    |
|     同一个包中     |         |    √    |     √     |   √    |
| 其它包中的子类内部 |         |         |     √     |   √    |
|     全局范围内     |         |         |           |   √    |



### 基类和派生类相关问题

1. 在创造派生类的过程中<font color=blue>首先创建基类对象，然后才能创建派生类</font>



### 外部类

​		对于外部类而言，它也可以使用访问控制符修饰，**<font color=red>但外部类只能有两种访问控制级别： public 和 default</font>**。**因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围**，因此 private 和 protected 访问控制符对外部类没有意义



### 内部类

#### 静态内部类

​		静态内部类定义在了成员位置上，并且使用static来去修饰；不可以访问外部的非静态资源，可以用 `public static final` 修饰符

​		包含静态内部类的类编译后会生成两个.class文件，一个是外部的类 `Outer.class` ，另一个是 `Outer$Inner.class`

​		生成静态内部类对象的方式：`Outer.Inner inner = new Outer.Inner()`

#### 成员内部类

​		成员内部类定义在外部类的成员位置上，可以访问外部的所有资源，但是**本身内部不能有静态属性**；因为自己本身需要依靠外部类的实例化

​		生成成员内部类的实例对象的语法：`Outer.Inner inner = new Outer().new Inner()`

内部类可以拥有<font color=red>**private访问权限、protected访问权限、public访问权限及包访问权限（default访问权限）:**</font>

- 如果成员内部类用private修饰，则只能在外部类的内部访问；
- 如果用public修饰，则任何地方都能访问；
- 如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；
- 如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰

#### 局部内部类

<font color=red>**无法被**</font>访问修饰符（**public、private和protected**）和`static` <font color=red>**修饰**</font>，**只能访问`final`变量和形参**

1. 局部静态内部类，在外部类的静态方法中
2. 局部内部类，在外部类的一般方法中

​        局部内部类会生成两个.class文件，一个是`Outer.class` ，另一个是`Outer$LocalInner.class`

​		局部内部类在实际开发中用的并不多

#### 匿名内部类

匿名内部类特点：

1. 没有构造器，没有静态资源，无法被访问修饰符和static修饰
2. 只能创建匿名内部类的一个实例
3. 创建的时候一定是在 new 的后面

````java
public static void main(String[] args) {
    new Runnable() {
        @Override
        public void run() {
            System.out.println("匿名内部类");
        }
    };
}
````

### i++和++i

Java使用了中间缓存变量机制：

**<font color=red>x++表示先运算，再自增</font>**

**<font color=red>++x表示先自增再参与运算</font>**

````java
i=i++;
等同于：
	temp=i； 
	i=i+1;      
	i=temp;  
//分割线--------------------------
i=++i;
则等同于：
	i=i+1;
	temp=i;
	i=temp;
````



### 代码块和静态代码块

#### 小结

- 静态代码块：最早执行，<font color=red>用static申明，**JVM加载类时执行**</font>，**只执行一次**（静态块按照 <font color=green>**申明顺序**</font> 执行）

- 构造代码块：执行时间比静态代码块晚，比构造函数早，和构造函数一样，只在**<font color=red>对象初始化</font>**的时候运行

  > 当有多个代码块的时候，会从上往下按顺序执行

- 构造函数：执行时间比构造代码块时间晚，也是在**对象初始化**的时候运行



执行顺序优先级：静态块 > main() > 构造块 > 构造方法

````java
public class B
{
    public static B t1 = new B();
    public static B t2 = new B();
    {
        System.out.println("构造块");
    }
    static
    {
        System.out.println("静态块");
    }
    public static void main(String[] args)
    {
        B t = new B();
    }
}
//输出：构造块 构造块 静态块 构造块
/**
 * 解析：
 *      1.静态块按照 申明顺序 执行,所以先执行public static B t1 = newB();
 *      2.该语句创建对象,则又会调用构造块,输出构造块
 *      3.然后再执行静态代码块的内容
 */
````



### Math工具类

#### ceil 和 floor

- `Math.ceil(d1)` ：ceil 方法上有这么一段注释：

  > If the argument value is less than zero but greater than -1.0, then the result is negative zero

  意思是：如果参数小于0且大于 -1.0，结果为 -0

- `Math.floor(d1)`：ceil 和 floor 方法 上都有一句话：

  > If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument

  意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，如果是 -0.0，那么其结果是 -0.0



### 字符串反转

利用 `StringBuffer` 或者 `StringBuilder` 的 `reverse()` 方法即可

````java
String str = "adrian";
StringBuffer stringBuffer = new StringBuffer(str);
stringBuffer.reverse().toString()
````



### 怎么确保一个集合不能被修改

````java
Collections.unmodifiableList(List list);
Collections.unmodifiableSet(Set set);
Collections.unmodifiableMap(Map m);

//带顺序的
Collections.unmodifiableSortedMap(Map m);
Collections.unmodifiableSortedSet(Set set);
````

​		调用这个方法返回的 集合 内容不可以被修改，如果修改会抛出异常`java.lang.UnsupportedOperationException`



### static 关键字

#### 静态方法

​		静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法

#### 初始化顺序

​		静态变量 和 静态语句块 优先于实例变量和普通语句块

​		静态变量 和 静态语句块 的初始化顺序取决于它们在代码中的顺序

**存在继承的情况下，初始化顺序为：**

1. 父类（静态变量、静态语句块）
2. 子类（静态变量、静态语句块）
3. 父类（实例变量、普通语句块）
4. 父类（构造函数）
5. 子类（实例变量、普通语句块）
6. 子类（构造函数）



### IO

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：`File`
- 字节操作：`InputStream` 和 `OutputStream`
- 字符操作：`Reader` 和 `Writer`
- 对象操作：`Serializable`
- 网络操作：`Socket`
- 新的输入/输出：`NIO`



#### 装饰者模式的应用

Java I/O 使用了装饰者模式来实现。以 `InputStream` 为例：

- `InputStream` 是抽象组件
- `FileInputStream` 是 `InputStream` 的子类，属于具体组件，提供了字节流的输入操作
- `FilterInputStream` 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 `BufferedInputStream` 为 `FileInputStream` 提供缓存的功能



​		实例化一个具有缓存功能的字节流对象时，只需要在 `FileInputStream` 对象上再套一层 `BufferedInputStream` 对象即可

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```



#### 序列化

序列化就是将一个对象转换成字节序列，方便存储和传输

- 序列化：`ObjectOutputStream.writeObject()`
- 反序列化：`ObjectInputStream.readObject()`

不会对**静态变量**进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。

​		序列化的类需要实现 `Serializable` 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常

​		`transient` 关键字可以使一些属性不会被序列化。

> ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据



### 继承相关问题

1. 子父类方法调用

   > ​		子类调用方法的时候：如果子类重写了父类的方法，那么会直接调用子类自身的方法，当在子类找不到该方法时，才会调用父类的方法