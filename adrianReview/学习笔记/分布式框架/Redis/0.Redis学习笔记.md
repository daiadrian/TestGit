Redis学习笔记

## NoSQL数据库

​	NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。

​	随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。

​	NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展

### 为什么要用NoSQL

1. 易扩展

   > NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。
   > 数据之间无关系，这样就非常容易扩展。这在架构的层面上带来了可扩展的能力

2. 大数据量高性能

   > ​	NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。
   > ​	一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。
   >
   > ​	但是NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了

3. 多样灵活的数据模型

   > ​	NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦

4. 传统RDBMS和NoSQL的对比

   | RDBMS                            | NoSQL                                                        |
   | :------------------------------- | :----------------------------------------------------------- |
   | 高度组织化结构化数据             | 没有声明性查询语言                                           |
   | 结构化查询语言（SQL）            | 没有预定义的模式（键-值对存储，列存储，文档存储，图形数据库） |
   | 数据和关系都存储在单独的表中     | 最终一致性，而非ACID属性                                     |
   | 数据操纵语言DML，数据定义语言DDL | 非结构化和不可预知的数据                                     |
   | 严格的一致性                     | CAP理论                                                      |
   | 基础事务                         | 高性能，高可用性和可伸缩性                                   |



### NoSQL数据库分类

1. K-V键值对存储

   > 常见：Redis、MemcacheDB
   >
   > 可以通过key快速查询到其value

2. 文档存储

   > 常见：MongoDB、CouchDB
   >
   > ​	文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能

3. 列存储

   > 常见：Hbase、Cassandra
   >
   > ​	按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势

4. 图存储

   > 常见：Neo4J



## Redis的概述

### Redis简介

​	Redis（REmote DIctionary Server）是完全开源免费的，用ANSI C语言编写的，遵守BSD协议，支持网络，并提供多种语言的API

​	Redis是一个**高性能**的（key/value）**<font color=red>分布式内存数据库</font>**，<font color=blue>基于内存运行并支持持久化</font>的NoSQL数据库，也被称为数据结构服务器



### 为什么要用Redis

1. 丰富的数据结构（支持多种数据类型）
2. Redis提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断
3. 数据存在内存中，读写非常的高速
4. 采用单线程模型，减少竞争，规避并发问题



### Redis的应用场景

1. 数据缓存
2. 排行榜
3. 计数器/限速器（统计播放量数据，浏览量，在线人数等）
4. 好友关系（点赞数，共同好友等）
5. 简单的消息队列（订阅发布/阻塞队列）
6. 分布式的Session

​	

### Redis的数据类型

#### 字符串String

​	string 是 redis 最基本的类型；**string 类型的值最大能存储 512MB**

**常用的命令**

````shell
#将字符串值 value 关联到 key （如果 key 已经有其他值， 那么就会覆写旧值）
## EX seconds 设置过期时间为指定的 秒数
## PX milliseconds 设置过期时间为指定的 毫秒数
SET key value [EX seconds] [PX milliseconds]

# 只在键 key 不存在的情况下， 将键 key 的值设置为 value
# 若键 key 已经存在， 则 SETNX 命令不做任何动作
## 命令在设置成功时返回 1 ， 设置失败时返回 0
SETNX key value

#返回与键 key 相关联的字符串值
##如果键key不存在，那么返回特殊值 nil； 否则返回键 key 的值
GET key

#为键 key 储存的数字值加上一
## 如果键 key 不存在， 那么它的值会先被初始化为 0， 然后再执行 INCR 命令
## 如果键 key 储存的值不是数字， 那么将返回一个错误
INCR key

#为键 key 储存的数字值加上增量 increment
##情况和INCR相同
INCRBY key increment

#为键 key 储存的数字值减去一
##情况和INCR相同
DECR key

#将键 key 储存的整数值减去减量 decrement
##情况和INCR相同
DECRBY key decrement

#如果键key已经存在并且它的值是一个字符串，那么将把 value 追加到键 key 现有值的末尾
#如果key不存在，就等同于SET命令
APPEND key value
````

##### HyperLogLog

​		其本质是**字符串**类型，基于HyperLogLog算法：极小空间完成独立数量统计



#### 列表list

​	Redis 列表是简单的字符串列表，按照插入顺序排序。底层是一个链表

**常用命令**

````shell
#将一个或多个值 value 插入到列表 key 的表头
##如果 key 不存在，一个空列表会被创建；当key存在但不是列表类型时，返回一个错误

##如果有多个value值，那么各个value值按从左到右的顺序依次插入到表头
##比如说，对空列表mylist执行命令LPUSH mylist a b c，列表的值将是 c b a 
##这等同于原子性地执行 LPUSH mylist a 、LPUSH mylist b 和 LPUSH mylist c三个命令
LPUSH key value [value …]

#相当于LPUSH操作，但是当 key 不存在时， LPUSHX 命令什么也不做
LPUSHX key value

#将一个或多个值 value 插入到列表 key 的表尾(最右边)
RPUSH key value [value …]
#相当于RPUSH操作，但是当 key 不存在时，RPUSHX 命令什么也不做
RPUSHX key value
#移除并返回列表 key 的头元素
LPOP key
#移除并返回列表 key 的尾元素
RPOP key

#返回列表 key 中，下标为 index 的元素
##从头元素到尾元素是从 0 开始
##从尾元素到头元素是从 -1开始，然后倒数第二个元素是-2，以此类推
LINDEX key index

#返回列表 key 的长度
LLEN key

#根据参数 count 的值，移除列表中与参数 value 相等的元素
##count的值可取：
#### count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为count 
#### count < 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为count的绝对值
#### count = 0 : 移除表中所有与 value 相等的值
LREM key count value

#返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定
##下标值和 LINDEX 定义相同
LRANGE key start stop

#将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。
#然后将source弹出的元素插入到列表 destination ，作为 destination 列表的的头元素
RPOPLPUSH source destination
````

1. RPOPLPUSH source destination 详解：

   > 举个例子：
   >
   > 1. 你有两个列表 `source` 和 `destination` ， `source` 列表有元素 `a, b, c` ， `destination` 列表有元素 `x, y, z` 
   > 2. 执行 `RPOPLPUSH source destination` 之后， `source` 列表包含元素 `a, b` ， `destination` 列表包含元素 `c, x, y, z` ，并且元素 `c` 会被返回给客户端

   ​	使用RPOPLPUSH命令可以作为一个安全的队列使用，因为RPOPLPUSH命令不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用LREM key count value命令将这个消息从备份表删除

   ​	还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去（负责处理该消息的客户端可能已经崩溃），这样就不会丢失任何消息了



#### 哈希表Hash

​	Redis hash 是一个键值对集合，它是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map<String,Object>

**常用命令**

````shell
#将哈希表hash中域field的值设置为value
##如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行HSET操作
##如果域field已经存在于哈希表中，那么它的旧值将被新值覆盖
###当HSET命令在哈希表中新创建field域并成功为它设置值时，命令返回 1
###如果域field已经存在于哈希表， 并且HSET命令成功使用新值覆盖了它的旧值，那么命令返回 0
HSET hash field value

#当且仅当域 field 尚未存在于哈希表的情况下，将它的值设置为value
HSETNX hash field value

#返回哈希表中给定域的值
##如果给定域不存在于哈希表中，又或者给定的哈希表并不存在，那么命令返回 nil
HGET hash field

#检查给定域 field 是否存在于哈希表 hash 当中;存在时返回 1 ，否则返回 0
HEXISTS hash field

#删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略
HDEL key field [field …]

#返回哈希表 key 中域的数量
HLEN key

#同时将多个 field-value (域-值)对设置到哈希表 key 中
##示例：HMSET website google www.google.com yahoo www.yahoo.com
HMSET key field value [field value …]

#返回哈希表 key 中的所有域
HKEYS key
````



#### 集合Set

​	Redis的Set是string类型的无序集合；集合是通过哈希表实现的（添加，删除，查找的复杂度都是O(1)）

**常用命令**

````shell
#将一个或多个member元素加入到集合 key 当中，已经存在于集合的member元素将被忽略
SADD key member [member …]

#判断 member 元素是否集合 key 的成员
##如果是则返回 1 ，否则都是返回 0
SISMEMBER key member

#移除并返回集合中的一个 随机元素(随机、随机、随机)
SPOP key

#移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略
SREM key member [member …]

#返回集合 key 的基数(集合中元素的数量)
SCARD key

#返回集合 key 中的所有成员
SMEMBERS key
````

1. SRANDMEMBER key [count] 详解：

   如果命令执行时，只提供了 `key` 参数，那么返回集合中的一个随机元素

   > 时间复杂度: 只提供 `key` 参数时为 O(1) 。如果提供了 `count` 参数，那么为 O(N) ，N 为返回数组的元素个数

   - 如果 `count` 为<font color=red>正数</font>，且小于集合基数，那么命令返回一个包含 `count` 个元素的数组，数组中的元素**各不相同**。如果 `count` 大于等于集合基数，那么返回整个集合
   - 如果 `count` 为<font color=red>负数</font>，那么命令返回一个数组，数组中的元素**可能会重复出现多次**，而数组的长度为 `count` 的绝对值

2. 交并差集

   - SINTER key [key …] 返回一个集合的全部成员，该集合是所有给定集合的交集
   - SUNION key [key …] 返回一个集合的全部成员，该集合是所有给定集合的并集
   - SDIFF key [key …] 返回一个集合的全部成员，该集合是所有给定集合之间的差集

   > 示例：
   >
   > ```shell
   > redis> SMEMBERS songs
   > 1) "Billie Jean"
   > 
   > redis> SMEMBERS my_songs
   > 1) "Believe Me"
   > 
   > redis> SUNION songs my_songs
   > 1) "Billie Jean"
   > 2) "Believe Me"
   > ```



#### 有序集合SortedSet（ZSet）

​	Redis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。

​	Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复

​	**SortedSet可以用作排行榜，点赞数等功能的实现**

**常用命令**

````shell
#将一个或多个 member 元素及其 score 值加入到有序集 key 当中
##如果某个member已经是有序集的成员，那么更新这个member的score值
##并通过重新插入这个member元素，来保证该member在正确的位置上
ZADD key score member [[score member] [score member] …]

#返回有序集key中，成员 member 的 score 值
ZSCORE key member

#为有序集 key 的成员 member 的 score 值加上增量 increment 。
#可以通过传递一个负数值increment，让score减去相应的值
## 比如 ZINCRBY key -5 member ，就是让member的score值减去 5
ZINCRBY key increment member

#返回有序集 key 的元素个数
ZCARD key

#返回有序集 key 中，score值在min和max之间(默认包括等于 min 或 max )的成员的数量
ZCOUNT key min max

#移除有序集 key 中的一个或多个成员，不存在的成员将被忽略
ZREM key member [member …]
````

1. ZRANGE key start stop [WITHSCORES]

   ​	返回有序集 `key` 中，指定区间内的成员；其中成员的位置按 `score` 值递增（**从小到大**）来排序，具有相同 `score` 值的成员按字典序来排列

   ````shell
   redis > ZRANGE salary 0 -1 WITHSCORES             # 显示整个有序集成员
   1) "jack"
   2) "3500"
   3) "tom"
   4) "5000"
   5) "boss"
   6) "10086"
   ````

   

2. ZREVRANGE key start stop [WITHSCORES]

   ​	返回有序集 `key` 中，指定区间内的成员。其中成员的位置按 `score` 值递减（**从大到小**）来排列。 具有相同 `score` 值的成员按字典序的逆序排列

   

3. ZRANK key member  （ 返回指定memeber的排名）

   ​	返回有序集 `key` 中成员 `member` 的排名。其中有序集成员按 `score` 值递增(从小到大)顺序排列；排名以 `0` 为底，也就是说， `score` 值最小的成员排名为 `0`

   ````shell
   redis> ZRANGE salary 0 -1 WITHSCORES        # 显示所有成员及其 score 值
   1) "peter"
   2) "3500"
   3) "tom"
   4) "4000"
   5) "jack"
   6) "5000"
   
   redis> ZRANK salary tom                     # 显示 tom 的薪水排名，第二
   (integer) 1
   ````


##### GEO地理位置信息地位

​		GEO是`Redis` 3.2 版本以后提供的功能：存储经纬度信息，计算两地的距离（直线距离，若需要驾车/步行之类的距离可以调用 百度/高德 开放API），范围计算等



### Redis配置文件解析

#### 常见参数说明

1. **daemonize** no

   > Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程

2. **port 6379**

   > 指定Redis监听端口，默认端口为6379

3. **bind 127.0.0.1**

   > 绑定的主机地址

4. **timeout 300**

   > 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能；单位是秒

5. **loglevel verbose**

   > ​	指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning
   >
   > ​	默认为verbose

6. **databases 16**

   > 设置数据库的数量，默认数据库为0，可以使用SELECT dbid 命令在连接上指定数据库id

7. **save <seconds> <changes>**

   ​	指定在多长时间内，有多少次更新操作，就将数据同步到数据文件（快照RDB），可以多个条件配合

   Redis默认配置文件中提供了三个条件：

   - **save 900 1**   （表示900秒（15分钟）内有1个更改）
   - **save 300 10**   （表示300秒（5分钟）内有10个更改）
   - **save 60 10000**   （表示60秒内有10000个更改）

8. **rdbcompression yes**

   > ​	指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大

9. **dbfilename dump.rdb**

   > 指定本地数据库文件名，默认值为dump.rdb（RDB快照）

10. **dir ./**

    > 指定本地数据库存放目录

11. **slaveof <masterip> <masterport>**

    > ​	设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步

12. **masterauth <master-password>**

    > 当master服务设置了密码保护时，slave服务连接master的密码

13. **requirepass adrian**

    ​	设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭

    ````shell
    [root@adrian redis]# ./src/redis-cli -p 6379 -a adrian
    或者
    [root@adrian redis]#  ./src/redis-cli -p 6379
    redis 127.0.0.1:6379> auth adrian
    OK
    ````

14. **maxclients 128**

    > ​	设置同一时间最大客户端连接数，默认无限制
    >
    > ​	Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制
    >
    > ​	当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息

15. **maxmemory <bytes>**

    > ​	<font color=red>指定Redis最大内存限制</font>，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作
    >
    > ​	Redis新的vm机制，会把Key存放内存，Value会存放在swap区

16. **appendonly no**

    > ​	指定是否在每次更新操作后进行日志记录，Redis在默认情况下是**异步**的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。（AOF持久化）
    >
    > ​	因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no

17. **appendfilename appendonly.aof**

    > 指定更新日志文件名，默认为appendonly.aof

18. **appendfsync everysec**

    指定更新日志条件，共有3个可选值： 

    - **no**：表示等操作系统进行数据缓存同步到磁盘（快） 
    - **always**：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）
    - **everysec**：表示每秒同步一次（折中，默认值）

    

19. vm-enabled no

    > ​		指定是否启用虚拟内存机制，默认值为no；VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中

20. vm-swap-file /tmp/redis.swap

    > 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享

21. vm-max-memory 0

    > ​		将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（Redis的索引数据 就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0

22. vm-page-size 32

    > ​		Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的
    >
    > ​		如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值

23. vm-pages 134217728

    >  	​		设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，在磁盘上每8个pages将消耗1byte的内存

24. vm-max-threads 4

    > ​		置访问swap文件的线程数,最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4

25. glueoutputbuf yes

    > 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启



### Redis慢查询

​		许多存储系统（如:`MySQL`）提供慢查询日志帮助开发与运维人员定位系统存在的慢操作；所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间；当超过预设阈值，就将这条命令的相关信息（例如：发生时间、耗时、命令的详细信息）记录到慢查询日志中

#### 慢查询配置

1. `slowlog-log-slower-than`：用来控制慢查询的阈值，所有执行时间超过该值的命令都会被记录下来。该值的单位为微秒（1微秒=1000ms），默认值为 10000

   - 如果设置为 0，那么所有的记录都会被记录下来
   - 如果设置为小于 0 的值，那么对于任何命令都不会记录，即关闭了慢查询
   - 可以通过在配置文件中设置，或者用 config set 命令来设置：`config set slowlog-log-slower-than 10000`
   - 线上推荐设置成1000（即1ms）；一般可根据应用的QPS来进行调整

2. `slowlog-max-len`：用来设置存储慢查询记录列表的大小，默认值为 `128`，

   - 当该列表满了时，如果有新的记录进来，那么 Redis 会把队最旧的记录清理掉，然后存储新的记录；<u>因为存放慢日志的是先进先出的队列，队列满的时候会将队列头的数据清除掉，再在队列尾放入新数据</u>
   - 在生产环境我们可以适当调大，**比如调成 `1000`**，这样就可以缓冲更多的记录，方便故障的排查
   - 可以通过在配置文件中设置，或者用 config set 命令来设置：`config set slowlog-max-len 1000`

3. 获取慢日志的命令

   - `slowlog get [n]`：n是返回慢日志的条数

     ```reStructuredText
     127.0.0.1:6379> slowlog get
      1) 1) (integer) 456
         2) (integer) 1531632044
         3) (integer) 3
         4) 1) "get"
            2) "m"
         5) "127.0.0.1:50106"
         6) ""
      2) 1) (integer) 455
         2) (integer) 1531632037
         3) (integer) 14
         4) 1) "keys"
            2) "*"
         5) "127.0.0.1:50106"
         6) ""
     ```

     `1)`慢查询记录 id； 
     `2)` 发起命令的时间戳； 
     `3)` 命令耗时，单位为微秒； 
     `4)` 该条记录的命令及参数； 
     `5)` 客户端网络套接字（ip: port）; 
     `6)` “”

4. 获取当前慢查询日志记录数

   - `slowlog len`

5. 慢查询日志重置（清空慢查询列表数据）

   - `slowlog reset`



### Redis pipeline

> RTT：往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延

​		`Redis`提供了批量操作命令（例如`mget`，`mset`等），有效的节约`RTT`，但大部分命令是不支持批量操作的，例如要执行`n`次`hgetall`命令，并没有`mhgetall`存在，需要消耗`n`次`RTT`

​		`Redis`的客户端和服务端可能不是在不同的机器上。例如客户端在北京，`Redis`服务端在上海，两地直线距离为1300公里，那么1次`RTT`时间=`1300×2/(300000×2/3)=13毫秒`（光在真空中传输速度为每秒30万公里,这里假设光纤的速度为光速的2/3），那么客户端在1秒内大约只能执行80次左右的命令，这个和`Redis`的高并发高吞吐背道而驰

​		`Pipeline`（流水线）机制能改善上面这类问题，它能将一组`Redis`命令进行组装，通过一次`RTT`传输给`Redis`，再将这组`Redis`命令按照顺序执行并装填结果返回给客户端

> <font color=red>**注意**</font>：`pipeline`不是原子性的，因为 `Redis` 是单线程的，每次只能执行一个命令，有可能在执行流水线的第一个命令后去执行别的命令然后再执行流水线的下一个命令；但是流水线的返回结果会按照命令顺序进行装填后再返回给客户端

​		`pipeline` 可以减少网络时间，但是每次`Pipeline`组装的命令个数不能没有节制，否则一次组装`Pipeline`数据量过大，一方面会增加客户端的等待时机；另一方面会造成一定的网络阻塞，可以将一次包含大量命令的`Pipeline`拆分成多次较小的`Pipeline`来完成

<font color=red>**`Pipeline`只能操作一个`Redis`实例**</font>



### Redis持久化（RDB和AOF）

#### RDB

​		RDB指：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
​		整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失

> fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程

- 优点：RDB适合适合大规模的数据恢复和对数据完整性和一致性要求不高的应用场景

- 缺点：因为在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。而且fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

#### AOF

​		AOF是以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），<font color=blue>只许追加文件但不改写文件</font>，redis启动之初会读取该文件重新构建数据，即redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

- 优点：
  - 每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘 ，性能较差但数据完整性比较好
  - 每秒同步：appendfsync everysec  异步操作。每秒记录，如果一秒内宕机，只有一秒有数据丢失
- 缺点：相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。aof运行效率要慢于rdb

> rewrite重写机制
>
> - AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof
>
> 重写原理
>
> - AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句
> - 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似
>
> 触发时机
>
> - Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发



#### RDB和AOF的抉择

> 启动优先级
>
> - 重启时，AOF会被优先载入来进行数据恢复（<font color=red>同时使用AOF和RDB时，只会载入AOF</font>，不会再载入RDB的文件数据）
>
> 文件体积
>
> - AOF的文件要比RDB大得多，所以载入AOF文件也要比RDB文件慢

1. `Redis` 只做缓存使用的时候，不需要开启任何一种持久化方式
2. RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则

>  **如果Enalbe AOF**，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了
>
>  - 代价一是带来了持续的IO
>  - 二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值
>
>  
>
>  **如果不Enable AOF** ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动
>
>  - 代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，**启动脚本也要比较两个Master/Slave中的RDB文件**，载入较新的那个（新浪微博就选用了这种架构）



### 主从复制

​		主从复制：是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)，数据的复制是单向的，只能由主节点到从节点

> 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点

#### 主从复制的作用

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式
2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余
3. 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量
4. 读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量
5. 高可用基石：主从复制是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础

#### 主从复制启用

从节点开启主从复制，有3种方式：

1. 配置文件： 在从服务器的配置文件中加入：slaveof <masterip> <masterport>
2. 启动命令： redis-server启动命令后加入：  --slaveof <masterip> <masterport>
3. 客户端命令： Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip>
   <masterport>，则该Redis实例成为从节点

> 通过  info replication 命令可以看到复制的一些信息



### Sentinel（哨兵模式）

​		**<font color=blue>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案</font>**

​		哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例**

其作用是：

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器
- 当哨兵监测到 master 宕机（主服务器进入下线状态）时，自动从从服务器中选举出新的主服务器，然后通过**<font color=red>发布订阅模式</font>**通知其他的从服务器，修改配置文件，让它们切换 master

主要功能：

- **监控（Monitoring）**： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常（通过PING）
- **提醒（Notification）**： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知
- **自动故障迁移（Automatic failover）**： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器



#### 主观下线

​		主观下线（Subjectively Down， 简称 SDOWN）指的是**单个Sentinel实例**对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）



#### 客观下线

​		客观下线（Objectively Down， 简称 ODOWN）指的是**多个 Sentinel 实例**在对同一个服务器做出 SDOWN 判断， 并且通过 `SENTINEL is-master-down-by-addr` 命令互相交流之后， 得出的服务器下线判断，然后开启 failover（故障切换）；只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线



#### Sentinel配置

````xml
sentinel monitor <masterName> <ip> <port> <quorum>
<!-- 
	masterName：redis集群的名称
	ip,port 为master的地址和端口
  	quorum：客观下线的依据，指至少有 quorum 个 sentinel 主观的认为这个master有故障，才会对这个master进行下线以及故障转移（quorum的值一般设置为sentinel个数的二分之一加1，例如3个sentinel就设置2）
-->
    
    
sentinel down-after-milliseconds <masterName> <timeout> 
<!-- 
	这个配置就是进行主观下线的一个依据
	某个sentinel先将master节点进行一个主观下线，然后会将这个判定通过 sentinel is-master-down-by-addr 这个命令问对应的节点是否也同样认为该addr的master节点要做客观下线
	最后当达成这一共识的sentinel个数达到前面说的quorum设置的这个值时，就会对该master节点下线进行故障转移
-->
````

注意：

1. 只有Sentinel 集群中大多数服务器认定master主观下线时master才会被认定为客观下线，才可以进行故障迁移

   > ​		也就是说：即使不管我们在sentinel monitor中 `quorum` 设置的数是多少，就算是满足了该值，只要达不到大多数，就不会发生故障迁移

2. 官方建议 sentinel 至少部署三台，且分布在不同机器

   >  		这里主要考虑到sentinel的可用性，假如我们只部署了两台sentinel，且`quorum`设置为1，也可以实现自动故障迁移
   >
   > ​		但假如其中一台sentinel挂了，就永远不会触发自动故障迁移，因为永远达不到大多数sentinel认定master主观下线了

3. sentinel monitor配置中的master IP尽量不要写127.0.0.1或localhost，因为客户端（如Jedis）获取master是根据这个获取的，若这样配置，jedis获取的ip则是127.0.0.1，这样就可能导致程序连接不上master

4. 当sentinel 启动后会自动的修改`sentinel.conf`文件，如已发现的master的slave信息，和集群中其它sentinel 的信息等，这样即使重启sentinel也能保持原来的状态

   > ​		注意：当集群服务器调整时，如更换sentinel的机器，或者新配置一个sentinel，请不要直接复制原来运行过得sentinel配置文件，因为其里面自动生成了以上说的那些信息，我们应该复制一个新的配置文件或者把自动生成的信息给删掉

5. 当发生故障迁移的时候，master的变更记录与slave更换master的修改会自动同步到redis的配置文件，这样即使重启redis也能保持变更后的状态

