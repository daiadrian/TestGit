RabbitMQ知识点汇总

## MQ基本概念

### AMQP

​	AMQP全称是Advanced Message Queuing Protocol，它是一个(分布式)消息传递协议

​	AMQP模型的基本视图是：消息发布者将消息发布到交换器（Exchange）中，交换器的角色有点类似于日常见到的邮局或者信箱。然后交换器把**消息的副本**分发到队列（Queue）中，分发消息的时候遵循的规则叫做绑定（Binding）。接着，消息中间件代理向订阅队列的消费者发送消息（push模式），或者消费者也可以主动从队列中拉取消息（fetch/pull模式）

​	发布者在发布消息的时候可以指定消息属性（消息元数据），某些消息元数据可能由消息中间件代理使用，其他消息元数据对于消息中间件代理而言是不透明的，仅供消息消费者使用。

​	由于网络是不可靠的，客户端可能无法接收消息或者处理消息失败，这个时候消息中间件代理无法感知消息是否正确传递到消费者中，因此AMQP模型提供了消息确认（Message Acknowledgement）的概念：当消息传递到消费者，消费者可以自动向消息中间件代理确认消息已经接收成功或者由应用程序开发者选择手动确认消息已经接收成功并且向消息中间件代理确认消息，消息中间件代理只有在接收到该消息(或者消息组)的确认通知后才会从队列中完全删除该消息。

​	在某些情况下，交换器无法正确路由到队列中，那么该消息就会返回给发布者，或者丢弃，或者如果消息中间件代理实现了”死信队列（Dead Letter Queue）”扩展，消息会被放置到死信队列中。消息发布者可以选择使用对应的参数控制路由失败的处理策略



### 绑定（Binding）

​	绑定（Binding）	是交换器路由消息到队列的规则。例如交换器E可以路由消息到队列Q，那么Q必须通过一定的规则绑定到E。绑定中使用的某些交换器的类型决定了它可以使用可选的路由键（RoutingKey）。路由键的作用类似于过滤器，可以筛选某些发布到交换器的消息路由到目标队列

​	如果发布的消息没有路由到任意一个目标队列，消息已经发布到交换器，交换器中没有任何绑定，这个时候消息会被丢弃或者返回给发布者，取决于消息发布者发布消息时候使用的参数

​	Exchange 和Queue的绑定可以是多对多的关系。即一个交换机可以绑定多个队列，一个队列也可以与多个交换机绑定



### 交换器（Exchange）

​	交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列；Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别

声明交互器的时候需要提供一些列的属性，其中比较重要的属性如下：

- Name：交互器的名称
- Type：交换器的类型
- Durability：持久化特性，如果启动此特性，则Broker重启后交换器依然存在，否则交换器会被删除
- Auto-delete：是否自动删除，如果启用此特性，当最后一个队列解除与交换器的绑定关系，交换器会被删除



#### Direct交换器

​	Direct是直接交换机的类型，如果消息中的路由键（routing-key）和bing中一致时，交换机就能将该消息发到对应的队列中。它是一种完全匹配才会发送的模式，可以构建点对点的消息传输模型

![Direct Exchange](.\mq\direct.png)



#### Fanout交换器

​	这是广播式的交换类型，即发到Fanout类型交换机上的消息都会被分发到与之绑定的所有队列上。Fanout类型转发消息的速度是最快的（因为它不处理路由键）

​	Fanout交换器会忽略路由键（不管路由键是什么都会分发消息到绑定的队列上），它会路由消息到所有绑定到它的队列。也就是说，如果有N个队列绑定到一个Fanout交换器，当一个新的消息发布到该Fanout交换器，那么这条新消息的一个副本会分发到这N个队列中

![Fanout Exchange](.\mq\Fanout.png)



#### Topic交换器

​	Topic交换器基于路由键和绑定队列和交换器的模式进行匹配从而把消息路由到一个或者多个队列。

​	对每一条消息，Topic交换器会遍历所有的绑定关系，检查消息指定的路由键是否匹配绑定关系中的路由键，如果匹配，则将消息推送到相应队列

绑定队列和交换器的Topic模式一般使用点号（’.’）分隔，例如`mq.dh.key`，绑定模式支持通配符：

- 符号`#`匹配一个或者多个词（**可以是0个**），例如：`mq.dh.#`可以匹配`mq.dh.adrian`、`mq.dh.adrian.zhku`等等。
- 符号`*`只能匹配一个词，例如：`mq.dh.*`可以匹配`mq.dh.adrian`、`mq.dh.zhku`等等。

![Topic Exchange](.\mq\Topic.png)



#### Header交换器

​	Headers交换器是一种不常用的交换器，它使用多个属性进行路由，这些属性一般称为消息头，它不使用路由键进行消息路由

​	消息头（Message Headers）是消息属性（消息元数据）部分，因此，使用Headers交换器在建立队列和交换器的绑定关系的时候需要指定一组键值对，发送消息到Headers交换器时候，需要在消息属性中携带一组键值对作为消息头。消息头属性支持匹配规则x-match如下：

- x-match = all：表示所有的键值对都匹配才能接受到消息。
- x-match = any：表示只要存在键值对匹配就能接受到消息。

Headers交换器也是忽略路由键的，只依赖于消息属性中的消息头进行消息路由



### 队列（Queue）

​	AMQP模型中的队列与其他消息或者任务队列系统中的队列非常相似：它们存储应用程序所使用的消息。队列和交换器的基本属性有类似的地方：

- Name：队列名称
- Durable：是否持久化，开启持久化意味着消息中间件代理重启后队列依然存在，否则队列会被删除
- Exclusive：是否独占的，开启队列独占特性意味着队列只能被一个连接使用并且连接关闭之后队列会被删除
- Auto-delete：是否自动删除，开启自动删除特性意味着队列至少有一个消费者并且最后一个消费者解除订阅状态(一般是消费者对应的通道关闭)后队列会自动删除
- Arguments：队列参数，一般和消息中间件代理或者插件的特性相关，如消息的过期时间（Message TTL）和队列长度等

​        一个队列只有被声明了（Declare）才能使用，也就是队列的第一次声明就是队列的创建操作（因为第一次声明的时候队列并不存在）。如果使用相同的参数再次声明已经存在的队列，那么此次声明会不生效（当然也不会出现异常）。但是如果使用不相同的参数再次声明已经存在的队列，那么会抛出通道级别的异常，异常代码是406（PRECONDITION_FAILED）

​	队列名必须由255字节(bytes)长度以内的UTF-8编码字符组成。而且以”amq.”开头的队列是由消息中间件代理内部生成的，有其特殊的作用，因此不能声明此类名称的新队列，否则会导致通道级别的异常，异常代码为403（ACCESS_REFUSED）

​	持久化的队列会持久化到磁盘中，这种队列在消息中间件代理重启后不会被删除。不开启持久化特性的队列称为瞬时(transient)队列，并非所有的场景都需要开启队列的持久化特性。

​	队列的持久化特性并不意味着路由到它上面的消息是持久化的，也就是**队列的持久化跟消息的持久化是两回事**。如果消息中间件代理挂了，它重启后会重新声明开启了持久化特性的队列，这些队列中只有使用了消息持久化特性的消息会被恢复

