# Sentinel 是什么？

​		随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性

## 主要的优点

- **<font color=orange>丰富的应用场景</font>**

  - 例如秒杀（即突发流量控制在系统容量可以承受的范围）
  - 消息削峰填谷
  - 集群流量控制
  - 实时熔断下游不可用应用等

- **<font color=orange>完备的实时监控</font>**

  - Sentinel 同时提供实时的监控功能

  - 可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况

- **<font color=orange>广泛的开源生态</font>**

  - Sentinel 提供开箱即用的与其它开源框架/库的整合模块

  - 例如与 Spring Cloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel

- **<font color=orange>完善的 SPI 扩展点</font>**

  - Sentinel 提供简单易用、完善的 SPI 扩展接口
  - 可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等



## 主要特性

Sentinel 分为两个部分:

- 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持
- 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器



![1.Sentinel主要特性](.\images\1.Sentinel主要特性.png)

- 绿色部分都是 Sentinel 核心库可以做的事情



## 基本概念

1. <font color=red>**资源**</font>

   - 资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容

     > 例如：
     >
     > - 由应用程序提供的服务
     > - 由应用程序调用的其它应用提供的服务
     > - 甚至可以是一段代码

   - 只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源



2. <font color=red>**规则**</font>
   - 围绕资源的实时状态设定的规则，可以包括**流量控制规则**、**熔断降级规**则以及**系统保护规则**
   - 所有规则可以动态实时调整



## 功能和设计理念

### 流量控制

​		流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究

​		任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。所以需要根据系统的处理能力对流量进行控制

​		Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：

![Sentinel流量控制](\images\2.Sentinel流量控制.png)

#### 流量控制设计理念

Sentinel 的设计理念是可以自由选择控制的角度，并进行灵活组合，从而达到想要的效果

流量控制有以下几个角度：

- <font color=red>资源的调用关系</font>
  - 例如资源的**调用链路**，资源和资源之间的关系
- <font color=red>运行指标</font>
  - 例如 QPS、线程池、系统负载等
- <font color=red>控制的效果</font>
  - 例如直接限流、冷启动、排队等



### 熔断降级

​		除了流量控制以外，及时对调用链路中的不稳定因素进行熔断也是 Sentinel 的使命之一

​		<font color=red>由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，可能会**导致请求发生堆积，进而导致级联错误**</font>

​		Sentinel 和 Hystrix 的原则是一致的：当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，<font color=red>则**对这个资源的调用进行限制，让请求快速失败**，避免影响到其它的资源而导致级联故障</font>

#### 熔断降级设计理念

在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法

Hystrix 通过 <font color=blue>线程池隔离 </font>的方式，来对依赖（在 Sentinel 的概念中对应资源）进行了隔离

- 这样做的好处是资源和资源之间做到了最彻底的隔离
- 缺点是除了增加了线程切换的成本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配



**<font color=orange>Sentinel 对这个问题（线程切换的成本）采取了两种手段：</font>**

1.  <font color=blue>通过并发线程数进行限制</font>
   - 和资源池隔离的方法不同，**Sentinel 通过限制资源并发线程的数量**，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小
   - 当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。**当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝**。堆积的线程完成任务后才开始继续接收请求



2.  <font color=blue>通过响应时间对资源进行降级</font>
   - 除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源
   - 当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复



### 系统自适应保护

​		Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环

​		当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用

​		针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求





# 流量控制

## 基于QPS/并发数的流量控制

流量控制主要有两种统计类型，一种是<font color=red>**统计并发线程数**</font>，另外一种则是<font color=red>**统计 QPS**</font>



### 并发线程数控制

​		**<font color=blue>并发数控制用于保护业务线程池不被慢调用耗尽</font>**

​		当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽

​		为应对太多线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离）。这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响

​		Sentinel 并发控制不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目（正在执行的调用数目），如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离



### QPS流量控制

​		当 QPS 超过某个阈值的时候，则采取措施进行流量控制



## 流量控制效果

流量控制的效果包括以下几种：**直接拒绝**、**Warm Up**、**匀速排队**



### 直接拒绝

**直接拒绝**（`RuleConstant.CONTROL_BEHAVIOR_DEFAULT`）方式是默认的流量控制方式

​		当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出`FlowException`。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时



### Warm Up 预热启动

Warm Up（`RuleConstant.CONTROL_BEHAVIOR_WARM_UP`）方式，即预热/冷启动方式

​		当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过 "冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮



### 匀速排队

匀速排队（`RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER`）

​		这个方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法

​		这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求





# 熔断降级

​		除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积

​		Sentinel **熔断降级** 会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误

​		当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 `DegradeException`）



## 降级策略

### 平均响应时间 (`DEGRADE_GRADE_RT`)

​		当 1s 内持续进入 N 个请求，并且对应时刻的平均响应时间（秒级）均超过阈值（`count`，以 ms 为单位），那么在接下的时间窗口（`DegradeRule` 中的 `timeWindow`，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 `DegradeException`）

​		注意 Sentinel 默认统计的 RT 上限是 4900 ms，**超出此阈值的都会算作 4900 ms**，若需要变更此上限可以通过启动配置项 `-Dcsp.sentinel.statistic.max.rt=xxx` 来配置



触发这个降级需要满足：

1. 平均响应时间超出阈值
2. 时间窗口内通过的请求 >= N（即QPS）



### 异常比例 (`DEGRADE_GRADE_EXCEPTION_RATIO`)

​		当资源的每秒请求量 >= N（可配置），并且每秒异常总数占通过量的比值超过阈值（`DegradeRule` 中的 `count`）之后，资源进入降级状态，即在接下的时间窗口（`DegradeRule` 中的 `timeWindow`，以 s 为单位）之内，对这个方法的调用都会自动地返回

​		异常比率的阈值范围是 `[0.0, 1.0]`，代表 0% - 100%



触发这个降级需要满足：

1. 异常比例（秒级统计）超过阈值
2. 时间窗口内通过的请求 >= N（即QPS）



### 异常数 (`DEGRADE_GRADE_EXCEPTION_COUNT`)

​		当资源近 1 分钟的异常数目超过阈值之后会进行熔断

​		注意由于统计时间窗口是分钟级别的，若 `timeWindow` 小于 60s，则结束熔断状态后仍可能再进入熔断状态





# 热点参数限流

## 何为热点？

​		热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：

- 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制
- 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制



​		热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效

​		Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式



# 系统规则

​		系统保护规则是<font color=red>从**应用级别**的入口流量进行控制</font>，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性

​		系统保护规则是应用整体维度的，而不是资源维度的，并且**仅对入口流量生效**。入口流量指的是进入应用的流量（`EntryType.IN`），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量

系统规则支持以下的模式：

- **Load 自适应**（仅对 Linux/Unix-like 机器生效）
  - 系统的 load1 作为启发指标，进行自适应系统保护
  - 当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 `maxQps * minRt` 估算得出。设定参考值一般是 `CPU cores * 2.5`
- **CPU usage**（1.5.0+ 版本）
  - 当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏
- **平均 RT**：
  - 当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒
- **并发线程数**：
  - 当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护
- **入口 QPS**：
  - 当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护



# @SentinelResource 注解

> 注意：**注解方式埋点不支持 private 方法**

​		`@SentinelResource` 用于定义资源，并提供可选的异常处理和 fallback 配置项。 `@SentinelResource` 注解包含以下属性：

- `value`：资源名称，必需项（不能为空）

  

- `entryType`：entry 类型，可选项（默认为 `EntryType.OUT`）

  

- `blockHandler` / `blockHandlerClass`

  -  `blockHandler` 对应处理 `BlockException` 的函数名称，可选项。<font color=blue>`blockHandler` 函数访问范围需要是 `public` ，返回类型需要与原方法相匹配</font>，参数类型需要和原方法相匹配并且**最后加一个额外的参数，类型为 `BlockException`**
  -  `blockHandler` 函数<font color=blue>默认需要和原方法在同一个类中</font>。若希望使用其他类的函数，则可以指定 `blockHandlerClass` 为对应的类的 `Class` 对象，**<font color=red>注意对应的函数必需为 static 函数</font>**，否则无法解析

  

- `fallback` / `fallbackClass`

  - fallback 函数名称，可选项，<font color=red>用于在**抛出异常的时候提供 fallback 处理**逻辑</font>

  - fallback 函数可以**针对所有类型的异常**（除了 `exceptionsToIgnore` 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：

    - 返回值类型必须与原函数返回值类型一致

    - 方法参数列表需要和原函数一致，或者可以额外多一个 `Throwable` 类型的参数用于接收对应的异常

    - fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 `fallbackClass` 为对应的类的 `Class` 对象，**注意对应的函数必需为 static 函数**，否则无法解析

  

- `defaultFallback`（since 1.6.0）

  - 默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）

  - 默认 fallback 函数可以针对所有类型的异常（除了 `exceptionsToIgnore` 里面排除的异常类型）进行处理。若<font color=red>同时配置了 fallback 和 defaultFallback，则**只有 fallback 会生效**</font>。defaultFallback 函数签名要求：

    - 返回值类型必须与原函数返回值类型一致

    - 方法参数列表需要为空，或者可以额外多一个 `Throwable` 类型的参数用于接收对应的异常

    - defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 `fallbackClass` 为对应的类的 `Class` 对象，**注意对应的函数必需为 static 函数**，否则无法解析

  

- `exceptionsToIgnore`（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出

> 注：1.6.0 之前的版本 fallback 函数只针对降级异常（`DegradeException`）进行处理，**不能针对业务异常进行处理**。



​		特别地，<font color=red>若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 `BlockException` 时**只会进入 `blockHandler` 处理逻辑**</font>

​		若未配置 `blockHandler`、`fallback` 和 `defaultFallback`，则被限流降级时会将 `BlockException` **直接抛出**（若方法本身未定义 `throws BlockException` 则会被 JVM 包装一层 `UndeclaredThrowableException`）





