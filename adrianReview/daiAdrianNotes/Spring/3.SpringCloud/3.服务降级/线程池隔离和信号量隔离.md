## 信号量和线程池的工作方式

​		信号量 Semaphore 是一个并发工具类，用来控制可同时并发的线程数，其内部维护了一组虚拟许可，通过构造器指定许可的数量，每次线程执行操作时先通过acquire方法获得许可，执行完毕再通过release方法释放许可。如果无可用许可，那么acquire方法将一直阻塞，直到其它线程释放许可

　　线程池用来控制实际工作的线程数量，通过线程复用的方式来减小内存开销。线程池可同时工作的线程数量是一定的，超过该数量的线程需进入线程队列等待，直到有可用的工作线程来执行任务



### 两者的区别

1. 实际工作的线程创建方式
   - 使用 Semaphore ，创建了多少线程，实际就会有多少线程进行执行，只是可同时执行的线程数量会受到限制
   - 使用线程池，创建的线程只是作为任务提交给线程池执行，实际工作的线程由线程池创建，并且实际工作的线程数量由线程池自己管理。简单来说，线程池实际工作的线程是work线程，是由线程池创建的，并由线程池自动控制实际并发的work线程数量
2. 限流是否自动实现
   - Semaphore 相当于一个信号灯，作用是对线程做限流，Semaphore 可以对你自己创建的的线程做限流（也可以对线程池的work线程做限流），Semaphore 的限流必须通过手动acquire和release来实现
   - 线程池的工作线程数达到上限，那么任务就会进行等待



## 线程池隔离

- 执行实际业务的代码的线程与请求线程（比如Tomcat线程）分离，请求线程可以自由控制离开的时间，这也是通常所说的异步编程，Hystrix 是结合 RxJava 来实现的异步编程。<font color=red>通过设置线程池大小来控制并发访问量，当线程饱和的时候可以拒绝服务，防止依赖问题扩散</font>
- 尽管线程池提供了线程隔离，客户端底层代码也必须要有超时设置，不能无限制的阻塞以致线程池一直饱和
- 线程池的主要缺点就是它增加了计算的开销，每个业务请求在执行的时候，会涉及到请求排队，调度和上下文切换。不过线程隔离开销足够小，不会产生重大的成本或性能的影响



## 信号量隔离

- 当依赖的服务是极低延迟的，比如访问内存缓存，就没有必要使用线程池的方式，那样的话开销得不偿失，而是推荐使用信号量隔离这种方式
- 线程池隔离和信号量隔离的主要区别：**线程池方式下业务请求线程和执行依赖的服务的线程不是同一个线程；信号量方式下业务请求线程和执行依赖服务的线程是同一个线程**
- 信号量隔离的方式是限制了总的并发数，每一次请求过来，请求线程和调用依赖服务的线程是同一个线程，那么如果不涉及远程RPC调用（没有网络开销）则使用信号量来隔离，更为轻量，开销更小



## Hystrix的实现

| 隔离方式   | 是否支持超时                                                 | 是否支持熔断                                                 | 隔离原理             | 是否是异步调用                         | 资源消耗                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- | -------------------------------------- | -------------------------------------------- |
| 线程池隔离 | 支持，可直接返回                                             | 支持，当线程池到达maxSize后，再请求会触发fallback接口进行熔断 | 每个服务单独用线程池 | 可以是异步，也可以是同步。看调用的方法 | 大，大量线程的上下文切换，容易造成机器负载高 |
| 信号量隔离 | 不支持，如果阻塞，只能通过调用协议（如：socket超时才能返回） | 支持，当信号量达到maxConcurrentRequests后，再请求会触发fallback | 通过信号量的计数器   | 同步调用，不支持异步                   | 小，只是个计数器                             |

### 信号量模式

　　在该模式下，接收请求和执行下游依赖在同一个线程内完成，不存在线程上下文切换所带来的性能开销，所以大部分场景应该选择信号量模式，但是在下面这种情况下，信号量模式并非是一个好的选择

> ​		比如一个接口中依赖了3个下游：serviceA、serviceB、serviceC，且这3个服务返回的数据互相不依赖，这种情况下如果针对A、B、C的熔断降级使用信号量模式，那么接口耗时就等于请求A、B、C服务耗时的总和，无疑这不是好的方案

　　另外，为了限制对下游依赖的并发调用量，可以配置 Hystrix 的 `execution.isolation.semaphore.maxConcurrentRequests`，当并发请求数达到阈值时，请求线程可以快速失败，执行降级

　　信号量模式的实现也很简单，一个简单的计数器，当请求进入熔断器时，执行`tryAcquire()`，计数器加1，结果大于阈值的话，就返回false，发生信号量拒绝事件，执行降级逻辑。当请求离开熔断器时，执行`release()`，计数器减1



### 线程池模式

　　在该模式下，用户请求会被提交到各自的线程池中执行，把执行每个下游服务的线程分离，从而达到资源隔离的作用。当线程池来不及处理并且请求队列塞满时，新进来的请求将快速失败，可以避免依赖问题扩散。在信号量模式提到的问题，对所依赖的多个下游服务，通过线程池的异步执行，可以有效的提高接口性能

线程池模式的优势

- 减少所依赖服务发生故障时的影响面

  > 如ServiceA服务发生异常，导致请求大量超时，对应的线程池被打满，这时并不影响ServiceB、ServiceC的调用

- 如果接口性能有变动，可以方便的动态调整线程池的参数或者是超时时间，前提是 Hystrix 参数实现了动态调整



#### 隔离方式

1. 服务分组+线程池
   - 粗粒度的实现方式，一个服务分组/系统 配置一个隔离线程池即可， 此时不需要配置线程池名称和分组
2. 服务分组+服务+线程池
   - 细粒度实现，一个服务分组中每一个服务配置一个隔离线程池，此时需要配置线程池的名称
3. 混合实现
   - 一个服务分组配置一个隔离线程池，然后对其中重要的服务单独设置隔离线程池



