并发控制

读写锁

并发控制有两种类型的锁：共享锁和排它锁，也称为读锁和写锁

- 读锁可以让多个用户同一时间读取同一个资源

- 写锁的话是互斥的，写锁会阻塞其他的写锁和读锁，这样才能确保同一时间内只有一个用户能执行写入操作，并且防止其他用户读取该资源

锁粒度

对于给定的资源，锁定的数据量越少，那么并发量就越高，这样能够提高共享资源的并发效率。但是加锁的操作是需要消耗资源的，锁的各种操作（获取锁，检查锁是否释放，释放锁等）都会增加系统的开销

锁策略：在锁开销和数据安全性之间寻求平衡，尽量提高性能

- 表级锁（table lock）
  - 开销最小的锁策略
  - 它会锁定整张表，一个用户对表的增删改等操作需要先获取锁，并且获取表级锁之后，其他用户对该表的读写操作都会被阻塞
  - 写锁的优先级比读锁高，因此可能写锁的请求会被插入到读锁队列的前面
- 行级锁
  - 行级锁可以最大程度的支持并发处理，但是也带来了最大的锁开销
  - InnoDB支持行级锁



死锁

​		死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁；多个事务同时锁定同一个资源也会产生死锁

> 死锁的例子：
>
> ```mysql
> #事务1
> START TRANSACTION;
> UPDATE my_table SET a=1  WHERE b=4;
> UPDATE my_table SET a=10 WHERE b=3;
> COMMIT;
> 
> #事务2
> START TRANSACTION;
> UPDATE my_table SET a=2 WHERE b=3;
> UPDATE my_table SET a=3 WHERE b=4;
> COMMIT;
> ```
>
> - 如果两个事务都执行了各自的第一条 UPDATE 语句，同时也会锁定该行的数据
> - 那么当尝试执行第二条UPDATE语句的时候，就会发现该行已经被其他事务给锁定了，就会等待其他事务释放锁
> - 这个时候相互持有对方需要的锁，就陷入了死锁的情况了



​		为了解决死锁的问题，数据库系统实现了各种死锁检测和死锁超市机制。如InnoDB存储引擎，能够检测到死锁的循环依赖，并立即返回一个错误。InnoDB处理死锁的方式是将持有最少行级排它锁的事务进行回滚操作



mysql事务

​		mysql默认采用自动提交（AUTOCOMMIT）模式，即如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作

​		可以通过设置AUTOCOMMIT变量来启动或者禁用自动提交模式，JDBC等dao层工具都是首先禁用自动提交模式的

> 注意：如MyISAM存储引擎是没有事务的，也就没有COMMIT或者ROLLBACK的概念

​		InnoDB是采用两阶段锁定协议；在事务执行过程中，随时都可以执行锁定操作，并且锁只有在执行COMMIT或者ROLLBACK的时候才会被释放，并且所有行的锁都是在同一时刻释放的

​		上面所说的是隐式的加锁操作，也可以使用显式的加锁操作。如：`select ... for update`



多版本并发控制MVCC

​		大多事务型存储引擎都不是简单的行级锁，因为行级锁的开销很大。所以基于提升并发性能的考虑，一般都实现了多版本并发控制。可以认为MVCC是行级锁的变种，但是它能够在很多情况下避免了加锁操作，从而开销更低；实现了非阻塞的读操作，同时写操作也是只锁定必要的行

​		MVCC是通过保存数据在某个时间节点的快照来实现的；也就是说不管执行多长时间，每个事务看到的数据都是一致的。根据事务的开始时间的不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的

> ​		解释：事务的开始时间不一样，那么对应数据的版本号就不一样，每个事务能看到的记录的版本号是比当前的事务中的版本号要低的，所以在不同事务中可能看到的数据不一致

​		InnoDB 的 MVCC 是通过在每行记录的后面保存两个隐藏的列来实现的。两个列分别是：保存行的创建时间，保存行的过期时间（或者删除时间）

​		但是存储的并不是真实的时间值，而是系统的版本号。每开始一个新的事务，这个版本号就会自动的递增。事务开始的系统版本号就会作为事务的版本号，用来和查询到的每一行记录的版本号进行比较

例子：MVCC在 Repeatable Read 隔离级别的操作

- SELECT 操作

  > InnoDB会根据下面的两个条件检查每行记录
  >
  > - InnoDB值查找版本早于当前事务版本的数据行（即行的版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么在数据开始前就已经存在，要么就是事务自身插入或者修改过的
  > - 行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除

- INSERT

  > 为新插入的行保存当前的系统版本号作为行的版本号

- DELETE

  > 为删除的行保存当前版本号作为行的删除标识

- UPDATE

  > 为插入的每一条新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识



​		保存这两个额外的系统版本号，能够使大多数的读操作都可以不用加锁。好处是性能很好，并且能够解决 “幻读” 问题。不足的是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及额外的维护工作

​		MVCC只在 Repeatable Read 和 Read Committed 两个隔离级别下工作。因为Read UnCommitted 总是读取最新的数据行，不符合版本号的设计思想。而串行化则会对所有的数据行都进行加锁操作

