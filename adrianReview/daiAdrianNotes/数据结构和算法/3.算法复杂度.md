# 时间复杂度分析方法

## 事后统计法

​		**事后统计法** 指的是对于两个算法，如何评判谁运行得更快，谁运行时更节省内存，可以把这两个算法运行一遍，然后再分别统计下这两个算法的运行时间和占用内存

但是这种统计方法具有非常明显的问题：

1. 不同的输入对结果影响很大
2. 不同的机器对结果影响很大
3. 数据规模对结果影响很大



## 渐近分析法

​		渐近分析法是指将算法执行的效率与输入的规模进行挂钩，随着输入规模的增大，算法执行所需要的时间（或空间）将呈现一种什么样的趋势，这种趋势就叫作**<font color=red>渐近</font>**，而这种方法就叫作 **<font color=orange>渐近分析法</font>**





## 最坏、平均、最好复杂度分析

对于数组数据 `[1, 8, 9, 3, 5, 6, 10, 13]`

使用从左往右遍历的方式查找元素



1. <font color=orange>对于**最坏情况**的复杂度分析</font>
   - 每次查找数组最后的元素或者每次都查找数组中不存在的元素
   - 那么线性查找的时间复杂度为O(n)
2. <font color=orange>对于**平均情况**的复杂度分析</font>
   - 平均的情况下就要考虑所有的情况，从第一个元素直到数组不存在的元素
   - 那么就是 `1/(n+1) + 2/(n+1) + ... + (n+1)/(n+1) = (n+2)/2` ，忽略常数项后也是O(n) 的复杂度
3. <font color=orange>对于**最好情况**的复杂度分析</font>
   - 每次查找都是第一个元素，那么时间复杂度是O(1)



​		<font color=red>**通常**</font>，我们使用最坏情况来评估算法的时间复杂度，这也是比较简单的一种评估方法，且往往也是比较准确的



### 最坏复杂度的分析问题

​		通常来说是可以直接使用最坏时间复杂度分析算法的，但是对于一些算法来说就不能使用这个方式进行分析了

#### 动态数组

​		给一个数组插入元素，但是该数组达到一定的长度后需要对数组进行扩容操作（该扩容操作是新开一个数组，再把旧数组数据进行复制）

​		所以当数组不需要扩容时，时间复杂度是 O(1)，但是当数组需要进行扩容再插入元素时，就需要 O(n) 的时间复杂度了

​		如果使用最坏的复杂度分析，那么这个算法的操作就是 O(n) ，显然是不合理的，插入前面 `(n-1)` 个元素的时候，它的时间复杂度都是 O(1)，就只有插入第n个元素的时候它的时间复杂度才是O(n)，所以这样来评估动态数组插入元素的时间复杂度明显不合理

​		那么，如果把第n个元素插入所需要的时间均摊到所有元素上会怎么样呢？这样的话，前面每个元素的插入时间只需要加1，变成O(2)，忽略常数项，就还是O(1)，这样明显是要合理一些

​		这种方式跟计算平均时间复杂度有点类似，但是，它不是平均时间复杂度，它有一个专门的名称叫做**均摊时间复杂度**

​		<font color=red>**均摊时间复杂度**，即对一批样本中出现的个例情况，将它们耗费的时间均摊到所有样本上，算出来的一个时间复杂度</font>

​		数组未满时额外空间复杂度为O(1)，数组满时额外空间复杂度为O(n)，均摊一下变成O(1)。所以，对于动态数组插入元素的过程，它的均摊时间复杂度和均摊额外空间复杂度都是O(1)





## 常见的时间复杂度

| 与n的关系      | 英文释义    | 复杂度   | 示例                         |
| -------------- | ----------- | -------- | ---------------------------- |
| 常数（不相关） | Constant    | O(1)     | 数组按索引查找元素           |
| 对数相关       | Logarithmic | O(logn)  | 二分查找                     |
| 线性相关       | Linear      | O(n)     | 遍历数组的元素               |
| 超线性相关     | Superlinear | O(nlogn) | 归并排序、堆排序             |
| 多项式相关     | Polynomial  | O(n^c)   | 冒泡排序、插入排序、选择排序 |
| 指数相关       | Exponential | O(c^n)   | 汉诺塔                       |
| 阶乘相关       | Factorial   | O(n!)    | 行列式展开                   |

可以将计算算法复杂度的套路归纳为以下五步：

1. 明确输入规模n；
2. 考虑最坏情况或均摊情况，如果最坏情况为个例，那就是均摊；
3. 计算算法执行的次数与n的关系，并用函数表示出来；
4. 去除低阶项；
5. 去除常数项；



> 比如，对于在数组中查找指定元素的操作：
>
> 1. 输入规模为数组的长度n；
> 2. 考虑最坏情况为目标元素不在数组中；
> 3. 算法的执行次数为遍历所有数组元素，也就是n次，用函数表示 f(n) = n；
> 4. 去除低阶项，没有低阶项，还是n；
> 5. 去除常数项，没有常数项，还是n；
>
> 所以，在数组中查找指定元素的时间复杂度为O(n)



# 空间复杂度与额外空间复杂度

```java
private static int[] multi1(int[] array) {
    int[] newArray = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        newArray[i] = array[i] * 2;
    }
    return newArray;
}

private static int[] multi2(int[] array) {
    for (int i = 0; i < array.length; i++) {
        array[i] = array[i] * 2;
    }
    return array;
}
```



## 空间复杂度

​		空间复杂度是指一个算法运行的过程占用的空间，这个空间包括输入参数的占用空间和额外申请的空间

所以，针对上面两个算法：

- 第一个算法，输入参数n，额外空间n，两者相加为2n，去除常数项，空间复杂度为O(n)；
- 第二个算法，输入参数n，额外空间0，两者相加为n，空间复杂度为O(n)。



​		可以看到，使用空间复杂度很难判断这两个算法的好坏，所以，诞生了另一个概念——额外空间复杂度



## 额外空间复杂度

​		**额外空间复杂度**，是指一个算法运行过程中额外申请的空间

使用额外空间复杂度，针对上面两个算法：

- 第一个算法，额外空间为n，额外空间复杂度为O(n)；
- 第二个算法，额外空间为0，额外空间复杂度为O(1)；



可以看到，使用额外空间复杂度能够很轻易地判断两个算法的好坏（从空间占用的角度）



## 时间与空间的权衡

​		在数据结构与算法中也是一样，时间与空间往往同时出现，而且经常朝着相反的方向运动

比如，对于排序算法：

- 冒泡排序，时间复杂度O(n^2)，空间复杂度O(1)
- 归并排序，时间复杂度O(nlogn)，空间复杂度O(n)



​		所以，有两种思想：以时间换空间，以空间换时间

​		如果有时间、空间同时比较小的为最好，退而求其次，选择以空间换时间，毕竟随着计算机硬件技术地不断发展，空间越来越不值钱，而时间却越来越值钱，所以以空间换时间也是一种常用的思想