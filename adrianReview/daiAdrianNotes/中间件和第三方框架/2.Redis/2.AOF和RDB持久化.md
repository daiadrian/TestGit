# RDB

​		RDB指：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是 Snapshot 快照，它恢复时是将快照文件直接读到内存里

​		Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件
​		整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效

​		RDB的缺点是最后一次持久化后的数据可能丢失

> fork 的作用是：复制一个与当前进程一样的进程
>
> ​		新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程



​		RDB文件的载入工作是**在服务器启动时自动执行**的，所以Redis**并没有专门用于载入RDB文件的命令**，只要Redis服务器在启动时检测到RDB文件存在，它就会**自动载入RDB文件**，服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止





## 手动触发机制

​		**手动触发分别对应save和bgsave命令**

​		bgsave 命令是针对 save 阻塞问题做的优化。Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃



### save命令

​		SAVE命令**会阻塞Redis服务器进程**，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。对于内存比较大的实例会造成长时间阻塞，***\*线上环境不建议使用\****



### bgsave命令

​		和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令**会派生（fork）出一个子进程**，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

​		阻塞只发生在fork阶段，一般时间很短



#### 运作流程

**bgsave是主流的触发RDB持久化方式，它的运作流程如下：**

1. 执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在bgsave命令直接返回
2. 父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看 `latest_fork_usec` 选项，可以获取最近一个fork操作的耗 时，单位为微秒

3. 父进程fork完成后，bgsave命令返回“Background saving started”信息 并不再阻塞父进程，可以继续响应其他命令

4. 子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的 `rdb_last_save_time` 选项

5. 进程发送信号给父进程表示完成，父进程更新统计信息



## 自动触发

​		bgsave 命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过**设置服务器配置的save选项**，让服务器每隔一段时间**自动执行一次bgsave命令**



### save选项的格式

- 使用save相关配置，如 “save m n” 。表示m秒内数据集存在n次修改时，自动触发bgsave

- 用户可以通过save选项设置多个保存条件，但**只要其中任意一个条件被满足，服务器就会执行bgsave命令**

- 如果用户没有主动设置save选项，那么服务器会为**save选项设置默认条件：**

  - `save 3600 1 300 100 60 10000`
  - 只要**满足以上三个条件中的任意一个**，BGSAVE命令就会被执行：
    - 服务器在3600秒之内，对数据库进行了至少1次修改
    - 服务器在300秒之内，对数据库进行了至少100次修改
    - 服务器在60秒之内，对数据库进行了至少10000次修改

  



## RDB优缺点

- 优点：
  - RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。**非常适用于备份，全量复制等场景**。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复
  - Redis加载RDB**恢复数据远远快于AOF的方式**
- 缺点：
  - fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑
  - **RDB方式数据没办法做到实时持久化/秒级持久化**。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高
  - 如果是宕机的话，会丢失最后一次快照的内容
  - RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，**存在老版本Redis服务无法兼容新版RDB格式的问题**





# AOF

​		AOF是以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），<font color=blue>只许追加文件但不改写文件</font>，redis启动之初会读取该文件重新构建数据，即 Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作



## AOF优缺点

- 优点：
  - 每修改同步：`appendfsync always`   同步持久化 每次发生数据变更会被立即记录到磁盘 ，性能较差但数据完整性比较好
  - 每秒同步：`appendfsync everysec`  异步操作。每秒记录，如果一秒内宕机，只有一秒有数据丢失
- 缺点：
  - 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。aof 运行效率要慢于rdb



## AOF的工作流程

1. **命令写入 （append）**

   - 当AOF持久化功能处于打开状态时，服务器在<font color=orange>**执行完一个写命令之后**</font>，会以Redis协议格式将被执行的写命令**<font color=orange>追加到服务器状态的AOF缓冲区（aof_buf）</font>**

2. **文件同步（sync）**

   - AOF缓冲区根据对应的策略向硬盘做同步操作

   - | **appendfsync选项的值** | **说明**                                                     |
     | ----------------------- | ------------------------------------------------------------ |
     | always                  | 命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回 |
     | everysec(默认值)        | 命令写入aof_buf后调用write系统调用将内容写入AOF文件，但是不同步。但是会创建一个专门独立的线程，每秒执行一次同步 |
     | no                      | 命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作，同步硬盘操作由操作系统负责，通常同步周期最长30秒 |

   - **<font color=orange>配置为always时：</font>**每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰， 不建议配置

   - **<font color=orange>配置为no时：</font>**由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证

   - **<font color=orange>配置为everysec时：</font>**是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据

3. **文件重写（rewrite）**

   - 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的

4. **重启加载 （load）**

   - 当Redis服务器重启时，可以加载AOF文件进行数据恢复
     - 如果服务器**开启了AOF持久**化功能，那么服务器**会优先使用AOF文件**来还原数据库状态，那么就不会使用RDB文件了
     - 只有在**AOF持久化功能处于关闭状态**时，服务器才会使用RDB文件来还原数据库状态





## Rewrite重写机制

​		AOF采用文件追加方式，文件会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对 Redis 服务器造成影响

​		为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 `bgrewriteaof`



### AOF重写时的内部过程

1. **执行AOF重写请求**
   - 如果当前进程正在执行AOF重写，请求不执行并返回如下响应：`ERR Background append only file rewriting already in progress`
   - 如果当前进程正在执行bgsave操作，重写命令延迟到bgsave完成之后再 执行，返回如下响应：`Background append only file rewriting scheduled`

2. **父进程执行fork创建子进程，开销等同于bgsave过程**

3. **主进程fork操作完成后，继续响应其他命令**
   - 所有修改命令依然写 入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确 性

4. **由于fork操作运用写时复制技术，子进程只能共享fork操作时的内 存数据**
   - 由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部 分新数据，防止新AOF文件生成期间丢失这部分数据

5. **子进程根据内存快照，按照命令合并规则写入到新的AOF文件**
   - 每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为 32MB，防止单次刷盘数据过多造成硬盘阻塞

6. **新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息**
   - 具体见 `info persistence` 下的aof_*相关统计

7. **父进程把AOF重写缓冲区的数据写入到新的AOF文件**

8. **使用新AOF文件替换老文件，完成AOF重写**



### 触发方式和时机

- **手动触发：**直接调用 bgrewriteaof 命令
- **自动触发：**根据 `auto-aof-rewrite-min-size` 和 `auto-aof-rewrite-percentage` 参数确定自动触发时机
  - **`auto-aof-rewrite-min-size`：**表示运行AOF重写时文件最小体积，默认为64MB。
  - **`auto-aof-rewrite-percentage`：**代表当前AOF文件空间 （`aof_current_size`）和上一次重写后AOF文件空间（`aof_base_size`）的比值



## AOF追加阻塞

​		当开启AOF持久化时，常用的同步硬盘的策略是 everysec，用于平衡性 能和数据安全性。对于这种方式，Redis使用另一条线程每秒执行 fsync 同步硬盘。当系统硬盘资源繁忙时，会造成Redis主线程阻塞



### 阻塞流程分析

1. 主线程负责写入AOF缓冲区

2. AOF线程负责每秒执行一次同步磁盘操作，并记录最近一次同步时 间

3. 主线程负责对比上次AOF同步时间：
   - 如果距上次同步成功时间在2秒内，主线程直接返回
   - 如果距上次同步成功时间超过2秒，主线程将会阻塞，直到同步操作完成



**通过对AOF阻塞流程可以发现两个问题：**

- everysec配置最多可能丢失2秒数据，不是1秒
- 如果系统fsync缓慢，将会导致Redis主线程阻塞影响效率



**AOF阻塞问题定位：**

- 每当发生AOF追加阻塞事件发生时，在 `info Persistence` 统计中， `aof_delayed_fsync` 指标会累加，查看这个指标方便定位AOF阻塞问题
- AOF同步最多允许2秒的延迟，当延迟发生时说明硬盘存在高负载问题，可以通过监控工具如 iotop，定位消耗硬盘IO资源的进程





# RDB和AOF的抉择

## 启动优先级

- 重启时，AOF会被优先载入来进行数据恢复（<font color=red>同时使用AOF和RDB时，只会载入AOF</font>，不会再载入RDB的文件数据）



## 文件体积

- AOF的文件要比RDB大得多，所以载入AOF文件也要比RDB文件慢



## 实际情况抉择

1. `Redis` 只做缓存使用的时候，不需要开启任何一种持久化方式

2. RDB文件只用作后备用途，建议只在 Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则

3. **如果Enalbe AOF**，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了

   - 代价一是带来了持续的IO

   - 二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值

     

4. **如果不Enable AOF** ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动

   - 代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，**启动脚本也要比较两个Master/Slave中的RDB文件**，载入较新的那个（新浪微博就选用了这种架构）



# fork操作

​		当Redis做RDB或AOF重写时，一个必不可少的操作就是执行fork操作创建子进程，**对于大多数操作系统来说fork是个重量级操作**

​		**虽然fork创建的子进程不需要拷贝父进程的物理内存空间，但是会复制父进程的空间内存页表**。例如对于10GB的Redis进程，需要复制大约20MB的内存页表，因此fork 操作耗时跟进程总内存量息息相关，如果使用虚拟化技术，特别是Xen虚拟机，fork操作会更耗时



## fork耗时问题定位

​		对于高流量的Redis实例OPS可达5万以上，如果fork操作耗时在秒级别将拖慢Redis几万条命令执行，对线上应用延迟影响非常 明显。正常情况下fork耗时应该是每GB消耗20毫秒左右

​		可以在 `info stats` 统计中查 `latest_fork_usec` 指标获取最近一次fork操作耗时，单位微秒



## 如何改善fork操作的耗时

1）**优先使用物理机或者高效支持fork操作的虚拟化技术**

2）**控制Redis实例最大可用内存**，fork耗时跟内存量成正比，线上建议每个Redis实例内存控制在10GB以内

3）**合理配置Linux内存分配策略**，避免物理内存不足导致fork失败

4）**降低fork操作的频率，**如适度放宽AOF自动触发时机，避免不必要的全量复制等