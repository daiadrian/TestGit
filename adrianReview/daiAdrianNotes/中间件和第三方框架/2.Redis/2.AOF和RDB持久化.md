# Redis持久化

## RDB

​		RDB指：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是 Snapshot 快照，它恢复时是将快照文件直接读到内存里

​		Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件
​		整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效

​		RDB的缺点是最后一次持久化后的数据可能丢失

> fork 的作用是：复制一个与当前进程一样的进程
>
> ​		新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程



### RDB优缺点

- 优点：
  - RDB适合适合大规模的数据恢复和对数据完整性和一致性要求不高的应用场景
- 缺点：
  - 因为在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改
  - 而且fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑





## AOF

​		AOF是以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），<font color=blue>只许追加文件但不改写文件</font>，redis启动之初会读取该文件重新构建数据，即 Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作



### AOF优缺点

- 优点：
  - 每修改同步：`appendfsync always`   同步持久化 每次发生数据变更会被立即记录到磁盘 ，性能较差但数据完整性比较好
  - 每秒同步：`appendfsync everysec`  异步操作。每秒记录，如果一秒内宕机，只有一秒有数据丢失
- 缺点：
  - 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb。aof 运行效率要慢于rdb



### rewrite重写机制

​		AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令`bgrewriteaof`



**重写原理**

- AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句
- 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似



**重写触发的时机**

- Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发



## RDB和AOF的抉择

### 启动优先级

- 重启时，AOF会被优先载入来进行数据恢复（<font color=red>同时使用AOF和RDB时，只会载入AOF</font>，不会再载入RDB的文件数据）



### 文件体积

- AOF的文件要比RDB大得多，所以载入AOF文件也要比RDB文件慢



### 实际情况抉择

1. `Redis` 只做缓存使用的时候，不需要开启任何一种持久化方式

2. RDB文件只用作后备用途，建议只在 Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则

3. **如果Enalbe AOF**，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了

   - 代价一是带来了持续的IO

   - 二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值

     

4. **如果不Enable AOF** ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动

   - 代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，**启动脚本也要比较两个Master/Slave中的RDB文件**，载入较新的那个（新浪微博就选用了这种架构）


