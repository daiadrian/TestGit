# Redis安装操作

## Redis安装

```shell
$ tar -zxzf redis-xxx.tar.gz
$ cd redis-xxx
$ make
```

### 启动和关闭

```shell
# 指定配置文件启动
$ ./redis-server redis.conf

#指定端口关闭
$ ./redis-cli -p 6379 shutdown
```



## Redis主从配置

```shell
# 对 slave 的配置文件进行修改
#添加主从配置
$ vi redis.conf
slaveof 127.0.0.1 6379

#查看是否配置成功的 redis-cli 下的命令
127.0.0.1:6379> info replication

# Replication 节点信息
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=0
slave1:ip=127.0.0.1,port=6381,state=online,offset=42,lag=0
master_replid:8591c12716f2097d7ddb4178d967ea0d0732abb6
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:42
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:42


# 指定端口访问redis, 加上 -p 指定端口
$ ./redis-cli -p 6380

# ./redis-cli -h 指定ip -p 指定端口 -a 指定密码
```



## Redis哨兵模式

### 配置文件详解

**failover ： 主从切换**

1. `port 26379`：sentinel监听端口，默认是26379

2. `sentinel monitor <master-name> <ip> <redis-port> <quorum>` 

   - 示例：`sentinel monitor mymaster 192.168.22.155 6379 2`
   - 告诉 Sentinel 去监听地址为 `ip:port` 的一个master，这里的 `master-name` 可以自定义，`quorum` 是一个数字（指明当有多少个sentinel认为一个master失效时，master才算真正失效，即客观下线）。`master-name` 只能包含英文字母，数字和 “.-_” 这三个字符需要注意的是 `master-ip` 要写真实的ip地址而不要用回环地址（127.0.0.1）

3. `sentinel auth-pass <master-name> <password>`

   - 示例：`sentinel auth-pass mymaster 123456test`
   - 设置连接 master和slave 时的密码，注意的是 Sentinel 不能分别为 master和slave 设置不同的密码，因此<font color=red> master和slave 的密码应该设置相同</font>

4. `sentinel down-after-milliseconds <master-name> <milliseconds>`

   - 示例：`sentinel down-after-milliseconds mymaster 30000`
   - 指定需要多少失效时间，一个master才会被这个 Sentinel <font color=red>主观地认为是不可用的</font>。 单位是毫秒，默认为30秒

5. `sentinel parallel-syncs <master-name> <numslaves> `

   - 示例：`sentinel parallel-syncs mymaster 1`

   - 指定了在发生 `failover` 主备切换时最多可以有多少个 slave 同时对新的 master 进行同步，这个数字越小，完成 `failover` 所需的时间就越长，但是如果这个数字越大，就意味着越多的 slave 因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个 slave 处于不能处理命令请求的状态

     > 备注：这个值说明，当主备切换时，其他从机会同步新的 master 的数据；但是当这个值越大时，就没有salve对外提供查询了，此时整体就会变得不可用，吞吐量会下降

6. `sentinel failover-timeout <master-name> <milliseconds>`

   - 示例：`sentinel failover-timeout mymaster 20000`
   - 故障转移的超时时间 failover-timeout 可以用在以下这些方面：
     - 同一个sentinel对同一个master两次failover之间的间隔时间
     - 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时
     - 当想要取消一个正在进行的failover所需要的时间。
     - 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了



### 开启哨兵模式

```shell
$ ./redis-sentinel /sentinel.conf
```

**配置文件**

```conf
# Example sentinel.conf

protected-mode no
port 26379
daemonize yes

pidfile "/var/run/redis-sentinel.pid"
logfile "/usr/local/software/redis/logs/log-6379/sentinel.log"
dir "/tmp"

sentinel myid 6fbd837cf750d5985ca21327c094f8c16e5f5ecb

sentinel deny-scripts-reconfig yes

sentinel monitor mymaster 127.0.0.1 6381 2

sentinel config-epoch mymaster 1
sentinel leader-epoch mymaster 1

# Generated by CONFIG REWRITE 自动生成
sentinel known-replica mymaster 127.0.0.1 6379
sentinel known-replica mymaster 127.0.0.1 6380
sentinel known-sentinel mymaster 127.0.0.1 26380 ff72bcc0354ad392cf6d9154287dc5f02746b404
sentinel known-sentinel mymaster 127.0.0.1 26381 1a13665a9999b50213cbf5c6bf251a68c63b60b6
sentinel current-epoch 1

```





# Jedis客户端

## JedisPool配置参数

1. maxTotal：资源池中最大连接数
2. maxIdle：资源池允许最大空闲的连接数（minIdle：资源池确保最少空闲的连接数）
3. blockWhenExhausted（默认true）：当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效
4. maxWaitMillis（默认-1）：当资源池连接用尽后，调用者的最大等待时间(单位为毫秒；-1表示永不超时)
5. testOnBorrow（默认false）：向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除（业务量很大时候建议设置为false(多一次ping的开销)）
6. testOnReturn（默认false）：向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除（业务量很大时候建议设置为false(多一次ping的开销)）
7. jmxEnabled：是否开启jmx监控，可用于监控（建议开启，但应用本身也要开启，默认开启）
8. testWhileIdle（默认false）：是否开启空闲资源监测
9. minEvictableIdleTimeMillis（默认30分钟）：资源池中资源最小空闲时间(单位为毫秒)，达到此值后空闲资源将被移除
10. timeBetweenEvictionRunsMillis（默认-1不检测）：空闲资源的检测周期(单位为毫秒)
11. numTestsPerEvictionRun：做空闲资源检测时，每次的采样数（可根据自身应用连接数进行微调,如果设置为-1，就是对所有连接做空闲监测）





## Jedis事务

````java
jedis.watch(lockName);
String result = jedis.get(lockName);
if (result != null && identifier.equals(result)){
    Transaction multi = jedis.multi();
    multi.del(lockName);
    List<Object> exec = multi.exec();
}
jedis.unwatch();
````



## RedisTemplate常用方法

### **redisTemplate.getExpire**和redisTemplate.expire

- getExpire
  - 获取key的过期时间，不存在该key返回**-2**；该key无过期时间则返回**-1**；否则返回该key 的过期时间，按秒返回

- expire
  - 为key设置过期时间，TimeUnit可以指定传入的long值的单位（例如：TimeUnit.MILLISECONDS指定单位为毫秒）

### RedisTemplate事务

````java
redisTemplate.watch(key);
String result = (String) redisTemplate.opsForValue().get(key);
if (result != null){
    redisTemplate.execute((RedisCallback)  redisConnection -> {
        redisConnection.multi();
        redisConnection.del(key.getBytes());
        List exec = redisConnection.exec();
        return exec;
    });
}
redisTemplate.unwatch();
````





## Redis异常

io.lettuce.core.RedisCommandTimeoutException: Command timed out

- 连接超时时间设置的过于短暂，修改为5000左右即可
- spring.redis.timeout=5000（连接超时时间）



