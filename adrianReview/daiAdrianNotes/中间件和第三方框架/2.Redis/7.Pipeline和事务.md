# Pipeline

## RTT

​		RTT 指的是往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延



**Redis客户端执行一条命令分为如下四个过程：**

- 1.发送命令
- 2.命令排队
- 3.命令执行
- 4.返回结果



以上的 1-4 的过程就称作 RTT



## Pipeline概述

​		Redis 提供了批量操作命令（例如`mget`，`mset`等），有效的节约 RTT，但大部分命令是不支持批量操作的，例如要执行 `n` 次 `hgetall` 命令，并没有 `mhgetall` 存在，需要消耗 n 次RTT

​		Redis 的客户端和服务端可能不是在不同的机器上。例如客户端在北京，Redis 服务端在上海，两地直线距离为1300公里，**那么1 次RTT时间=1300×2/(300000×2/3)=13毫秒**（光在真空中传输速度为每秒30万公里，这里假设光纤的速度为光速的2/3），那么客户端在1秒内大约只能执行80次左右的命令，这个和 Redis 的高并发高吞吐背道而驰

​		<font color=red>`Pipeline`（流水线）机制能改善上面这类问题，它能将一组 Redis 命令进行组装，通过一次RTT传输给Redis</font>，再将这组Redis命令按照顺序执行并装填结果返回给客户端



### Jedis使用

```java
try {
    jedis = pool.getResource();
    //获取 jedis 对象的 pipeline 对象
    Pipeline pipe = jedis.pipelined();
    for(String key : keys){
        //将多个key放入 pipeline 删除指令中
        pipe.del(key); 
    }
    //执行命令
    pipe.sync(); 
} catch (Exception e) {
    e.printStackTrace();
} finally {
    pool.returnBrokenResource(jedis);
}
```





## Pipeline注意事项

1. <font color=red>**`Pipeline`不是原子性的**</font>

   - 因为 Redis 是单线程的，每次只能执行一个命令，有可能在执行流水线的第一个命令后去执行别的命令然后再执行流水线的下一个命令

   - 但是流水线的返回结果会按照命令顺序进行装填后再返回给客户端

     

2. <font color=red>**`Pipeline` 可以减少网络时间**，但是每次 `Pipeline` 组装的命令个数不能没有节制</font>，否则一次组装 `Pipeline` 数据量过大，一方面会增加客户端的等待时机；另一方面会造成一定的网络阻塞

   - 可以将一次包含大量命令的 `Pipeline` 拆分成多次较小的 `Pipeline` 来完成
   - 当客户端和服务端的网络延时越大，`Pipeline` 的效果越明显

   

3. <font color=red>**`Pipeline`只能操作一个`Redis`实例**</font>





# 事务

## 事务命令

​		**Redis的事务比较简单，**主要是因为它<font color=red>**不支持事务中的回滚**特性</font>，同时无法实现命令之间的逻辑关系计算



**Redis只提供了四个命令管理事务：**

- **MULTI**

  - 用来开启一个事务

  - 开启一个事务之后，输入的命令不会被立即执行，而是进入事务队列中（入队），所以可以看见输入命令的结果显示为 “QUEUED”

    

- **WATCH**

  - 是一个乐观锁

  - 它可以在EXEC命令执行之前，**监视任意数量的数据库键**，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复

    

- **DISCARD**

  - 用于取消本次事务，放弃执行事务块内的所有命令

  - 如果使用了WATCH，DISCARD将取消监视连接监视的所有键

    

- **EXEC**：提交一个事务



## 事务错误处理

1. <font color=blue>**命令错误**</font>

   - 如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么 Redis 将**拒绝执行**这个事务

     

2. <font color=blue>**运行时错误（执行错误）**</font>

   - 有些事务输入的命令没有错误，但是语法或逻辑有错误，这类错误不会被立即检测出来，只有当事务提交时才会被检测出来

   - <font color=green>即使在事务的执行过程中发生了错误，**服务器也不会中断事务的执行**，它会**继续执行事务中余下的其他命令**，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响</font>

   - 因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理， 所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响

     

3. <font color=blue>**服务器停机**</font>

   - 如果 Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：
     - 如果服务器**<font color=green>运行在无持久化的内存模式下</font>**，那么重启之后的数据库将是空白的，因此数据总是一致的
     - 如果服务器**<font color=green>运行在RDB模式下，那么在事务中途停机不会导致不一致性</font>**，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的
     - 如果服务器**<font color=green>运行在AOF模式下，那么在事务中途停机不会导致不一致性</font>**，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的
   - 综上所述，**无论Redis服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性**

