# 什么是CAP理论

​		CAP理论指的是在一个**分布式系统**中，不能同时满足一致性，可用性和分区容错性

1. <font color=orange>**C（Consistency）：一致性**</font>

   > 在分布式系统中的所有数据备份，在同一时刻是否是同样的值

2. <font color=orange>**A（Availabe）：可用性**</font>

   > ​		可用性指在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求
   >
   > ​		可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。“有效的时间内”是指，对于用户的一个操作请求，**系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的**

3. <font color=orange>**P（Partition Tolenrance）：分区容错性**</font>

   > ​		分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障
   >
   > ​		以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用

​		我们经常所说分布式应用是无法达到CAP三者兼顾的，但**CAP理论定义的其实是在容忍网络分区的条件下，“强一致性”和“极致可用性”无法同时达到**



## 分区

​		一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区

​		当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了

​		然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。

​		总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低





### 分区容错性

​		分区容错性约束了一个分布式系统具有如下特性：<font color=red>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</font>

​		

**网络分区**

​		网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况；但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。

​		需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区







## Consistency一致性强弱

​		一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即**<font color=red>数据变动在系统内部各节点应该是同步的</font>**

根据一致性强弱可分为：

1. **强一致性**（Strong Consistency）任何时刻，任何用户都能读取到最近一次成功更新的数据
2. **单调一致性**（Monotonic Consistency）任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说**可获取的数据顺序必是单调递增的**
3. **会话一致性**（Session Consistency）任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在<font color=blue>本次会话中就不会再读到比这个值更旧的值</font>。<u>会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障</u>
4. **最终一致性**（Eventual Consistency）用户只能读到某次更新后的值，<font color=blue>但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障</font>
5. **弱一致性**（Weak Consistency）用户无法在确定时间内读到最新更新的值



## CAP的抉择

| **选    择** | **说    明**                                                 |
| ------------ | :----------------------------------------------------------- |
| CA           | 放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择 |
| AP           | 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此 |
| CP           | 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用 |



### 简单的CAP例子

​	一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取	

  1. **假设DB的更新操作是同时写北京和广州的DB都成功才返回成功**

      > 在没有出现网络故障的时候，满足CA原则
      >
      > - C 即我的任何一个写入，更新操作成功并返回客户端完成后，分布式的所有节点在同一时间的数据完全一致
      > - A 即我的读写操作都能够成功
      >
      > <font color=blue>但是当出现网络故障时，我不能同时保证CA，即P条件无法满足</font>


  2. **假设DB的更新操作是只写本地机房成功就返回，通过binlog/oplog回放方式同步至侧边机房**

      > ​		这种操作保证了在出现网络故障时，双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP 
      >
      > ​		但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在**<font color=red>短暂数据不一致</font>**，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）


  3. **假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务**

      > ​		降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是这无法满足可用性原则



### 选择权衡

​		对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么<u>分布式系统中的组件必然需要被部署到不同的节点</u>，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统往往需要根据业务特点在C（一致性）和A（可用性）之间寻求平衡

​		对于大多数互联网应用来说，因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有舍弃强一致性（可以保证最终一致性）来保证服务的AP

​		但是对于需要确保强一致性的场景，如银行业务，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）



# Base理论

​		BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。

​		BASE理论的核心思想是：**<font color=red>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</font>**

1. Basically Available（基本可用）

   > 基本可用是指分布式系统在出现不可预知故障的时候，<font color=blue>允许损失部分可用性</font>
   >
   > 注意，这绝不等价于系统不可用。如：
   >
   > - 响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒
   >
   > - 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面

2. Soft state（软状态）

   > ​		软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即**允许系统在不同节点的数据副本之间进行数据同步的过程存在延时**

3. Eventually consistent（最终一致性）

   > ​		最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态
   >
   > ​		因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性



## 最终一致性变种

1. 因果一致性：

   > ​		因果一致性是指：如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制

2. 读己之所写：

   > ​		读己之所写是指：进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值
   >
   > ​		也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性

3. 会话一致性：

   > ​		会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性
   >
   > ​		也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值

4. 单调读一致性：

   > ​       单调读一致性是指：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值

5. 单调写一致性：

   >  单调写一致性是指：一个系统需要能够保证来自同一个进程的写操作被顺序地执行



​		总的来说：BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是**通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态**。

​		在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用