分布式事务的实现主要有以下 5 种方案：

- XA 方案
- TCC 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案



### *可靠消息实现最终一致性

RocketMQ 的实现方案

1. A 系统先发送一个 prepared 消息到 mq，如果这个 <font color=red>prepared **消息发送失败那么就直接取消操作**别执行了</font>
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务
4. mq 会自动**定时轮询**所有 prepared 消息回调你的接口；问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿

![RocketMQ最终一致性](images\0.RocketMQ最终一致性.png)



其他MQ的实现方案：

1. A 系统先执行本地的事务，在事务中发送 MQ 消息，如果发送失败并且重试失败，那么直接回滚事务；这里如果是kafka，那么开启 `ack=all`，即所有 follower 都收到这个消息后才算是发送成功 
2. B 系统监听 MQ 队列中的消息，如果有消息，那么拉取消息执行本地的事务，当本地事务执行完成后才发送确认信息到 MQ 中
3. 如果B系统的事务出现异常，否则一直重试失败，那么就发送报警由人工手动回滚或者补偿
4. 对于消息丢失问题：
   - 发送方开启 `ack=all` 的应答模式保证发送成功
   - MQ 配置高可用，消息持久化保证消息不丢失
   - 消费方保证执行完事务后再应答 MQ 成功消费
5. 对于消息重复消费问题：
   - B系统如果事务处理很慢或者发生异常重试的情况下，MQ有可能会重发消息到B系统；B系统需要保证自己接口的幂等性即可
     - 可以通过数据库唯一索引来保证插入数据时的幂等性（再次插入出现异常，这个异常捕获不作处理）
     - 或者是消息里面带一个唯一ID值，在处理这个事务之前，使用这个唯一ID去setnx到redis里面，如果成功，那么就可以进行操作，否则都不进行处理。事务处理完成应答 MQ 后可以删除该值



### XA两阶段提交

​		有一个**事务管理器**的概念，负责协调多个数据库（资源管理器）的事务；事务管理器先问问各个数据库你准备好了吗？

- 如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作
- 如果任何其中一个数据库回答不 ok，那么就回滚事务

> 这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景



### TCC方案

TCC 的全称是：`Try`、`Confirm`、`Cancel`。

- <font color=blue>Try 阶段：</font>这个阶段说的是对各个服务的资源做检测以及对资源进行**锁定或者预留**
- <font color=blue>Confirm 阶段：</font>这个阶段说的是在各个服务中**执行实际的操作**
- <font color=blue>Cancel 阶段：</font>如果任何一个服务的业务方法执行出错，那么这里就需要**进行补偿**，就是执行已经执行成功的业务逻辑的回滚操作（把那些执行成功的回滚）

> ​		因为TCC方案需要写很多补偿代码（即事务发生异常的时候进行回滚操作的补偿代码），分布式事务很多的情况下，补偿代码也需要很多
>
> ​		一般来说跟**钱**相关的，跟钱打交道的，**支付**、**交易**相关的场景
>
> ​		会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题

![TCC方案](images\0.TCC方案.png)



### 本地消息表

1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表
2. 接着 A 系统将这个消息发送到 MQ 中去
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样**保证不会重复处理消息**
4. <font color=red>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态</font>
5. 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时<font color=blue> A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理</font>，这里保证消息不会丢失
6. 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止

![本地消息表方案](images\0.本地消息表方案.png)



### 最大努力通知方案

1. 系统 A 本地事务执行完之后，发送个消息到 MQ
2. 这里会有个专门消费 MQ 的**最大努力通知服务**，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口
3. 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃（告警通知人工回滚或者补偿）

