# 应用限流

​		每个API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时候，就必须考虑限流来保证接口的可用性或者降级可用性。即接口也需要安装上保险丝，以防止非预期的请求对系统压力过大而引起的系统瘫痪



## 限流简介

限流就是通过对并发访问/请求进行限速或一个时间窗口内的请求进行限速，从而达到保护系统的目的

一般系统可以通过压测来 **预估能处理的峰值**，一旦达到设定的峰值阀值，则可以：

- 拒绝服务（定向错误页或告知资源没有了）
- 排队或等待（例如：秒杀、评论、下单）
- 降级（返回默认数据）



## 限流常见方式

1. <font color=red>**限制总并发数**</font>
   - 比如数据库连接池、线程池
2. <font color=red>**限制瞬时并发数**</font>
   - 如 Nginx 的 `limit_conn` 模块，用来限制瞬时并发连接数
3. <font color=red>**限制时间窗口内的平均速率**</font>
   - 如 Guava 的 `RateLimiter`、Nginx 的 `limit_req` 模块，限制每秒的平均速率
4. <font color=red>**限制远程接口调用速率**</font>
5. <font color=red>**限制MQ的消费速率**</font>
6. 还可以根据网络连接数，网络流量，CPU或内存负载等进行限流



# 限流常用算法

## 计数器法

​		该算法主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流



### 临界问题

这个方法有一个致命问题：<font color=red>**临界问题**</font>

​		当遇到恶意请求，比如设定的阈值是1分钟内100次请求，在59秒时，瞬间请求100次，并且在60秒时请求100次，那么这个用户在1秒内请求了200次，用户可以在重置节点（就是重置计数器的值）时突发请求，而瞬间超过设置的速率限制，用户可能通过算法漏洞击垮应用



## 滑动窗口算法

​		滑动窗口算法类似将上面计数器法的 1秒 时间拆分成若干个小窗口（此例拆分成4个窗口），每个窗口对应 250ms

​		假设用户利用上一秒最后一刻和下一秒第一刻发起瞬间的高并发请求；此时会统计前一秒中的最后750ms 和下一秒的 前250ms ，这样能够判断出用户的访问依旧超过了 1s 的访问数量，因此依然会阻拦用户的访问



## 漏桶算法

​		水（指请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水（请求）流入速度过大会直接溢出（访问频率超过接口响应速率），然后就拒绝请求（丢弃溢出的数据包）；可以看出**漏桶算法能强行限制数据的传输速率**

> 漏桶算法描述：
>
> 1. 一个固定容量的漏桶，按照常量固定速率流出水滴
> 2. 如果桶是空的，则不需要流出水滴
> 3. 可以以任意速率流入水滴到漏桶
> 4. 如果流入水滴超出了桶的容量，则流入的水滴溢出（被丢弃），而漏桶的容量是不变的



​		因为漏桶的漏出速率是固定的，所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使流突发（burst）到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率

![漏桶算法示意图](.\images\LeakyBucket.jpg)



## 令牌桶算法

​		令牌桶算法，是一个存放固定容量令牌的桶，按照固定的速率往桶里添加令牌

​		随着时间流逝，系统会按恒定 1/QPS 时间间隔（单位是 ms）往桶里加入Token；如果桶已经满了就不再加了，新请求来临时会拿走一个Token，如果没有Token可拿了就阻塞（可以加入等待队列）或者拒绝服务

​		**令牌桶的好处是可以方便的改变速度**：一旦需要提高速率（应对突发传输），则按需提高放入桶中的令牌的速率.。一般会定时（比如100毫秒）往桶中增加一定数量的令牌，有些变种算法则实时的计算应该增加的令牌的数量



基本流程描述：

1. 假设限制 2r/s ，则按照 500ms 的固定速率往桶中添加令牌
2. 桶中最多存放 b 个令牌，当桶满时，新添加的令牌会被丢弃或者拒绝
3. 当一个 n 个字节大小的数据包到达时，将从桶中删除 n 个令牌，接着数据包被发送到网络上
4. 如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么在缓冲区等待）



### 令牌桶和漏桶算法的对比

- 拒绝请求的方式
  - <font color=red>令牌桶是按照固定的速率**往桶中添加令牌**</font>，请求是否被处理要看桶中的令牌是否足够，当令牌数量减为零时，则拒绝新的请求
  - <font color=red>漏桶则是按照常量固定速率**流出请求**</font>，流入请求的速率任意，当流入的请求数累积达到漏桶容量时，则拒绝新的请求
- 限制
  - 令牌桶限制的是平均流入速率，允许一定程度的突发流量
    - 即桶中有5个令牌，每秒添加一个令牌，这一次消费直接消耗了10个令牌，那么下一次请求（假设消耗1个令牌的请求）进来，就需要等待 5 秒的时间才有新的令牌可取
  - 漏桶限制的是常量流出速率





# 分布式限流

​		分布式限流最关键的是要将限流服务做成原子化，解决方案可以使用 Nginx + Lua 或者 Redis + Lua 技术实现





# 接入层限流（Nginx）

​		接入层通常指请求流量的入口，该层主要的目的是：负载均衡、非法请求过滤、请求聚合、缓存、降级、限流、AB测试、服务质量监控等

​		接入层的限流可以使用Nginx自带的两个模块实现：连接数限流模块 `ngx_http_limit_conn_module` 和漏桶算法实现的请求限流模块 `ngx_http_limit_req_module`



## 连接数限流模块

​		`limit_conn` 是对某个 key 对应的总的网络连接数进行限流（即限流某个 key 的总连接数）

​		但是不是每个请求连接都会被计数器统计，只有被 Nginx 处理并且读取了整个请求头的请求连接才会被记录下来



### 配置示例

```nginx
http{
    limit_conn_zone $binary_reomte_addr zone=test:10m;
    limit_conn_log_level error;
    limit_conn_status 503;
    
    server{
        location /limit {
            limit_conn test 1;
        }    
    }    
}
```



- `limit_conn_zone`

  - 用来配置限流 key 及存放 key 对应信息的共享内存区域大小

    - `$binary_reomte_addr` 是表示 IP 地址的限流
    - `$server_name` 可以表示域名级别的最大连接数限流

    

- `limit_conn_log_level`

  - 配置记录被限流后的日志级别，默认为 `error`

- `limit_conn_status`

  - 配置被限流后返回的状态码，默认为503

- `limit_conn`

  - 要配置存放 key 和计数器的共享内存区域和指定 key 的最大连接数
  - 配置 1 即表示Nginx 最多同时并发处理 1 个连接



### 主要执行过程

1. 请求进入后首先判断当前 `limmit_conn_zone` 中对应 key 的连接数是否超出了配置的最大连接数
2. 如果超出配置最大大小，则被限流，返回 `limit_conn_status` 定义的错误状态码。否则对应 key 的连接数加 1，并注册请求处理完成的回调函数
3. 进行请求处理
4. 在请求结束阶段会调用注册的回调函数，将对应 key 的连接数减 1





## 请求连接模块

### 配置示例

```nginx
http{
    limit_req_zone $binary_reomte_addr zone=test:10m rate=10r/s;
    limit_conn_log_level error;
    limit_conn_status 503;
    
    server{
        location /limit {
            limit_req zone=test burst=5 nodelay;
        }    
    }    
}
```



- `limit_req_zone`

  - 配置限流 key 和存放 key 对应信息的共享内存区域大小，rate 是配置固定速率

  - 固定速率指：如果配置了 10r/s ，即每秒 10 个请求，每 100ms 处理一个请求

    

- `limit_req`

  - 配置限流区域，桶容量（突然容量，默认为 0），是否延迟模式（默认为延迟模式，不配置 `nodelay` 即延迟模式）



### 主要执行过程

1. 请求进入后首先判断最后一次请求时间相当于当前时间（第一次是0）是否需要限流，如果需要限流则执行步骤2，否则执行步骤3
2. 如果没有配置桶容量（burst），按照固定速率处理请求，如果请求被限流，返回默认状态码
   - 如果 `burst > 0` 及 延迟模式
     - 如果桶满了，则新进入的请求被限流
     - 如果没有满，则请求会以固定的速率被处理
   - 如果 `burst > 0` 及 非延迟模式（配置了 nodelay），则不会按照固定速率处理请求，而是允许突发处理请求
     - 如果桶满了，那么请求被限流，返回默认状态码
3. 如果没有被限流，则正常处理请求
4. Nginx 会在相应的时机选择一些（3个节点）限流 key 进行过期处理，进行内存的回收