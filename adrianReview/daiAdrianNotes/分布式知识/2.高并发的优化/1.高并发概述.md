# 系统设计原则

## 高并发原则

1. 无状态

   - 应用无状态，配置文件有状态

2. 系统拆分

   - 系统维度（业务），读写维度（读服务和写服务），功能维度等

3. 服务化

4. 消息队列解耦，异步处理，流量削峰/缓存

5. **<font color=blue>数据异构</font>**

   - 数据记录分库分表

   - <font color=red>**数据闭环**</font>

     基本步骤：

     - 数据异构：通过如MQ机制接收数据变更，然后原子化存储到合适的存储引擎，如Redis等
     - 数据聚合：可选步骤；数据异构的目的是把数据从多个数据源拿过来，数据聚合的目的就是将这些数据做聚合然后让前端能够直接通过一次调用就能得到所有数据
     - 前端展示：前端通过一次或者少量几次调用获取到整体所需要的数据

     > 在做数据分片的时候可以通过同一个商品的ID做分片的key值，这样同一个商品的数据就会在同一个实例里面

   - 数据闭环和数据异构目的都是实现数据的自我控制，当其他系统出现了问题时不会影响当前的系统

6. 缓存

7. 并发化获取多个应用数据



## 高可用原则

1. 降级
   - 目的是大流量进来时，保障核心服务的可用性，并保障数据的最终一致性。可以把一些同步调用改成异步调用，优先处理优先级高的数据或者某些特征数据，合理分配进入系统的流量，以保障系统的可用性
2. 限流
   - 目的是防止恶意的请求流量、恶意攻击或者防止流量超出系统峰值
3. 切换流量
   - 目的是某个机房或者服务器挂掉了，需要进行流量切换
   - 切换手段
     1. DNS切换机房入口
     2. 切换故障的Nginx接入层或者应用层
4. 可回滚
   - 版本化。如事务回滚、代码库回滚、部署版本回滚、数据版本回滚、静态资源回滚等



# 高可用方案

## 隔离

​		隔离是指将系统或资源分隔开

​		系统隔离是为了在系统发生故障时，能限定传播范围和影响范围，即发生故障后不会出现滚雪球效应，从而保证只有出问题的服务不可用，其他服务是可用的

​		资源隔离是通过隔离来减少资源竞争，保障服务间的相互不影响和可用性



### 主要的隔离方式

1. <font color=blue>**线程池隔离**</font>

2. 进程隔离
   - 拆分成子系统，子系统之间进程隔离
3. 集群隔离
   - 服务分组
     - 如商品详情服务和秒杀服务都依赖商品服务，因为秒杀服务调用流量较大且稳定性低，为了不影响商品详情服务，可以抽出一个商品服务集群专门给秒杀服务使用，而这个抽出来的集群作为一个分组存在
4. 机房隔离
   - 多机房部署的情况下，每个机房应该有自己的服务分组，本机房的服务应该只调用本机房的服务
5. 读写隔离
   - 即关系型/非关系型数据库的读写分离
6. 动静隔离
   - 一般将静态资源放在CDN上
7. 爬虫隔离
8. 热点隔离
   - 热点数据，读数据使用多级缓存，写数据使用缓存+消息队列进行削峰



### Hystrix实现隔离

1. 限制调用分布式服务的资源使用，某一个调用服务出现问题不会影响其他的服务调用，通过线程池隔离和信号量隔离实现
2. 提供了优雅的降级机制：超时降级、资源不足时（线程或信号量）降级，且降级后可以配合降级接口返回兜底数据
3. 提供了熔断实现，当失败率达到阈值自动触发降级（如因网络故障超时造成的失败率高），熔断器触发的快速失败也会进行快速恢复
4. 提供了请求缓存、请求合并实现



<font color=blue>**线程池隔离**</font>

- 执行实际业务的代码的线程与请求线程（比如Tomcat线程）分离，请求线程可以自由控制离开的时间，这也是通常所说的异步编程，Hystrix 是结合 RxJava 来实现的异步编程。<font color=red>通过设置线程池大小来控制并发访问量，当线程饱和的时候可以拒绝服务，防止依赖问题扩散</font>
- 尽管线程池提供了线程隔离，客户端底层代码也必须要有超时设置，不能无限制的阻塞以致线程池一直饱和
- 线程池的主要缺点就是它增加了计算的开销，每个业务请求在执行的时候，会涉及到请求排队，调度和上下文切换。不过线程隔离开销足够小，不会产生重大的成本或性能的影响



<font color=blue>**信号量隔离**</font>

- 当依赖的服务是极低延迟的，比如访问内存缓存，就没有必要使用线程池的方式，那样的话开销得不偿失，而是推荐使用信号量隔离这种方式
- 线程池隔离和信号量隔离的主要区别：**线程池方式下业务请求线程和执行依赖的服务的线程不是同一个线程；信号量方式下业务请求线程和执行依赖服务的线程是同一个线程**
- 信号量隔离的方式是限制了总的并发数，每一次请求过来，请求线程和调用依赖服务的线程是同一个线程，那么如果不涉及远程RPC调用（没有网络开销）则使用信号量来隔离，更为轻量，开销更小