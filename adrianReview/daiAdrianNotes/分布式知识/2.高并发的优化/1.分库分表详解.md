### 分表

​		**单表数据量太大**（几千万数据行），会极大影响 sql **执行的性能**，到了后面 sql 可能就跑的很慢了。一般来说，单表到几百万的时候，性能就会相对差一些了，这个时候就得分表了

​		分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内

> 太平洋分表模式：
>
> - 亲子网，按照 ID 的 取模 （%10） 进行分表
> - 汽车网：
>   - 日志表按照月份进行分表（有自动创建往后一年的表的定时任务）
>   - 线索表，按照月份分表



### 分库

​		分库就是一个库一般最多支撑到并发 2000，超过这个并发的时候就一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么就可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了



|              | 分库分表前                   | 分库分表后                                   |
| ------------ | ---------------------------- | -------------------------------------------- |
| 并发支撑情况 | MySQL 单机部署，扛不住高并发 | MySQL从单机到多机，能承受的并发增加了多倍    |
| 磁盘使用情况 | MySQL 单机磁盘容量几乎撑满   | 拆分为多个库，数据库服务器磁盘使用率大大降低 |
| SQL 执行性能 | 单表数据量太大，SQL 越跑越慢 | 单表数据量减少，SQL 执行效率明显提升         |



### 垂直拆分和水平拆分

​		水平拆分的意思，就是把<font color=blue>**一个表的数据给弄到多个库的多个表里去**，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据</font>。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容

![](.\images\1.水平拆分.png)

​		垂直拆分<font color=red>就是把**一个有很多字段的表给拆分成多个表**，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段</font>。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好

![](.\images\2.垂直拆分.png)







### 数据迁移方案

#### 停机迁移方案

​		停掉系统的入口，没有流量继续写入。然后利用准备好的导数据的程序，将旧表的数据迁移到分库分表后的数据表里面。当这些数据都导完后，更新系统进行分库分表后的功能更新，然后开启停掉的入口



#### 双写迁移方案

​		线上系统里面，之前所有写库的地方，增删改操作，**除了对老库增删改，都加上对新库的增删改**，这就是所谓的<font color=red>**双写**，同时写俩库，老库和新库</font>。

​		然后**系统部署**之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据 `update_time` 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。

​		导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。

​		接着当数据完全一致了，基于仅仅使用分库分表的最新代码，重新部署一次

![](.\images\1.双写迁移方案.png)



### 分库分表中间件(了解即可)

#### Sharding-jdbc

​		当当开源的，属于 client 层方案，目前已经更名为 `ShardingSphere`（后文所提到的 `Sharding-jdbc`，等同于 `ShardingSphere`）。支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）

#### Mycat

​		基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善

#### 总结

​		`Sharding-jdbc` 这种 client 层方案的**优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高**，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要**耦合** `Sharding-jdbc` 的依赖；

​		`Mycat` 这种 proxy 层方案的**缺点在于需要部署**，自己运维一套中间件，运维成本高，但是**好处在于对于各个项目是透明的**



