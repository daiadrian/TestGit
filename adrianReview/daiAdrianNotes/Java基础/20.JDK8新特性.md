## lambda

### lambda删除list元素

```java
List<Teacher> teacherList = new ArrayList<>();
teacherList.removeIf(e -> {
    if (null == e.getIsRegistration()) {
        return false;
    }
    return e.getIsRegistration() == 1;
});

//removeIf
default boolean removeIf(Predicate<? super E> filter);
//接收一个参数,返回一个boolean值
public interface Predicate<T> {
    boolean test(T t);
}
```



## Stream

 		Stream 是用函数式编程方式在集合类上进行复杂操作的工具，开发者可以更容易地使用 Lambda 表达式，并且更方便地实现对集合的查找、遍历、过滤以及常见计算等 

 		Stream 通过将集合转换为一种叫 “流” 的元素序列，通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作 

​		<font color=red>流是一次性的，和迭代器类似，只能迭代一次</font>

```java
Stream<String> stream = list.stream().sorted().limit(10);         
List<String> newList = stream.collect(Collectors.toList());
//这一行会报错, 因为第二行已经消费过流了, 这个流已经不能再使用了
List<String> newList2 = stream.collect(Collectors.toList());
```



### 1.stream()

1. 将集合转换为流  `Stream<String> stream = new ArrayList<String>().stream()`
2. 数组创建流：`Stream<T> stream =  Arrays.stream(T[ ]) `





### 2.列表过滤

` filter(T -> boolean)`

- 保留 boolean 为 true 的元素 

```java
//保留年龄大于等于20的元素
//filter接收的是 Predicate 断言型的,接收一个对象,返回boolean
list = list.stream()
            .filter(person -> person.getAge() >= 20)
            .collect(Collectors.toList());
```



### 3.去除重复元素 

`distinct()`

- 去除重复元素，这个方法是通过类的 equals 方法来判断两个元素是否相等的

```java
list = list.stream()
            .distinct()
            .collect(Collectors.toList());
```



### 4.排序

`sorted() / sorted((T, T) -> int)`

- 如果流中的元素的类实现了 Comparable 接口，即有自己的排序规则，那么可以直接调用 sorted() 方法对元素进行排序，如 Stream<Integer>
- 反之, 需要调用 `sorted((T, T) -> int)` 实现 Comparator 接口 

> Comparator的compare方法，返回大于0的数就交换位置

```java
//已经有自己排序规则的情况
list = new ArrayList<Integer>().stream
    							.sorted()
    							.collect(Collectors.toList());

//自定义排序规则的情况
list = new ArrayList<Person>();
//根据年龄按照小到大排序    
list = list.stream()
            .sorted((p1, p2) -> p1.getAge() - p2.getAge())
            .collect(Collectors.toList());

//简写方式
list = list.stream()
            .sorted(Comparator.comparingInt(User::getAge))
            .collect(Collectors.toList());
```



### 5.limit和skip

1. `limit(long n)`
   - <font color=red>返回**前 n 个**元素</font> 
2. `skip(long n)`
   - <font color=red>**去除**前 n 个元素</font> 
3. 一起使用时需要注意：
   - skip(m) 用在 limit(n) 前面时，先去除前 m 个元素，然后再返回剩余元素的前 n 个元素 
   - limit(n) 用在 skip(m) 前面时，先返回前 n 个元素，然后再在剩余的 n 个元素中去除 m 个元素 



### 6.map(T -> R)

 将流中的每一个元素 T 映射为 R 

```java
List<String> nameList = list.stream()
                                .map(User::getName)
                                .collect(Collectors.toList());
```

​		nameList 中的元素就是 User 列表中每一个 User 的 name 属性

​		map中接收的是功能函数Function<T, R>，`R apply(T t)` 它接受一个对象，然后执行逻辑后会返回一个对象



### 7.flatMap(T -> Stream\<R\>)

 将流中的每一个元素 T 映射为一个流，再把每一个流连接成为一个流 



```java
List<String> list = new ArrayList<>();
list.add("aaa bbb ccc");
list.add("ddd eee fff");
list.add("ggg hhh iii");

list = list.stream()
            .map(s -> s.split(" "))
            .flatMap(Arrays::stream)
            .collect(Collectors.toList());
```

上述代码解析

- map 方法分割每个字符串元素，但此时流的类型为 Stream<String[ ]>，
  - 因为 split 方法返回的是 String[ ] 类型 
- flatMap 方法
  - 先使用 `Arrays::stream` 将每个 String[ ] 元素变成一个 Stream\<String\> 流
  - 然后 flatMap 会将每一个流连接成为一个流，最终返回我们需要的 Stream\<String\> 



### 8.条件匹配满足

1. `anyMatch(T -> boolean)`
   - 流中<font color=red>是否**有一个元素**匹配</font>给定的 `T -> boolean` 条件
2. `allMatch(T -> boolean)`
   - 流中<font color=red>是否**所有元素**都匹配</font>给定的 `T -> boolean` 条件 
3. `noneMatch(T -> boolean)`
   - 流中<font color=red>是否**没有元素匹配**</font>给定的 `T -> boolean` 条件 



```java
// 是否存在一个 user对象的 age 等于 18
boolean b = list.stream().anyMatch(user -> user.getAge() == 18);

// 是否所有user对象的 age 都大于18
boolean b = list.stream().allMatch(user -> user.getAge() > 18);

// 是否有user对象的 age 小于18
boolean b = list.stream().noneMatch(user -> user.getAge() < 18);
```



### 9.计数

`count()`

- 返回流中元素个数，结果为 long 类型 

```java
long num = list.stream().count();
```

`average()`

- 返回列表的平均数，注意要是可计算数值的



### 10.forEach()

 为该流的每个元素执行一个操作 ， 返回结果为 void。接收的是 Consumer 消费类型的函数

```java
//可以遍历元素
list.stream().forEach(System.out::println);

//调用Mapper向数据库插入新的元素
list.stream().forEach(UserMapper::insertUser);

//为每个元素设置名称
list.stream().forEach(u -> u.setName("设置名字"));
```



### 11.reduce



### 12.collect(常用)

 		Collect 方法作为终端操作，接受的是一个 Collector 接口参数，能对数据进行一些收集归总操作 

1. 收集最常用的方法，是把流中所有元素收集到一个 List, Set 或 Collection 中。如下：
   - toList
   - toSet
   - toCollection
   - toMap

```java
List newlist = list.stream.collect(Collectors.toList());

Map<Integer, User> map = list.stream()
    				.collect(Collectors.toMap(User::getId, p -> p));
//注意：如果Map的Key重复了，会报错
```



2. `joining` 连接字符串

```java
String s = list.stream().map(User::getName).collect(joining(","));
```



3. `groupingBy` 
   - 用于将数据分组，最终返回一个 Map 类型 

```java
//按照年龄分组
Map<Integer, List<User>> map = list.stream()
    							.collect(groupingBy(User::getAge));
// User::getAge 决定 Map 的键(Integer 类型)
// list 类型决定 Map 的值(List<User> 类型)
```



4. `partitioningBy`
   - 分区； 分区与分组的区别在于，分区是按照 true 和 false 来分的，因此partitioningBy 接受的参数的 lambda 也是 `T -> boolean` 

```java
//根据年龄是否小于等于20来分区
Map<Boolean, List<User>> map = list.stream()
                     .collect(partitioningBy(p -> p.getAge() <= 20));

//打印输出
{
    false=[User{name='Lucy', age=25}, User{name='Leon', age=21}], 
    true=[User{name='Tom', age=18}]
}
```

