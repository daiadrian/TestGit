## Map

​		Map是一种（key/value）的映射结构，Map中的元素是一个key只能对应一个value，**不能存在重复的key**

​		它是一个接口



## HashMap

​		HashMap采用 key/value 存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序

> 线程不安全是因为，多线程添加元素时，在扩容过程容易出现环形结构的链表

- HashMap实现了Cloneable，可以被克隆。

- HashMap实现了Serializable，可以被序列化。

- HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能

### 红黑树结构

​		HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶

​		在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。

​		当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率

​		数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率



- 初始容量是 16，即桶的数量
- 默认装载因子是 0.75
- 当一个桶中的元素个数**<font color=red>大于等于8</font>**时进行树化；当桶中的元素个数**<font color=red>小于等于6</font>**时把树转化为链表
- 当桶的使用数量达到 `threshold = capacity * loadFactor` 时进行扩容（当前桶的容量 * 装载因子）
- 初始化时如果自行传入初始容量，那么会计算扩容门槛，扩容门槛为<font color=red>传入的初始容量往上**取最近的2的n次方**</font>



#### put方法流程

![HashMap插入元素流程JDK8](images\91.HashMap插入元素流程JDK8.png)

（1）计算key的hash值；

（2）如果桶（数组）数量为0，则初始化桶

（3）如果key所在的桶没有元素，则直接插入

（4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转**（9）**处理

（5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点

（6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中

（7）如果找到了对应key的元素，则转后续流程**（9）**处理

（8）如果没找到对应key的元素，则在链表最后插入一个新节点并<font color=red>判断是否需要树化</font>

（9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值

（10）如果插入了元素，则数量加1并<font color=red>判断是否需要扩容</font>

> 注意：树化和扩容操作都是在**插入元素之后**才会进行判断是否需要的



#### resize扩容

```java
// size 是当前Map中的元素数量
//threshold就是需要扩容的临界点, 是当前桶的数量 * 装载因子
if (++size > threshold)
    resize();
```

（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12

（2）如果使用的是<font color=blue>非默认构造方法</font>，则第一次插入元素时初始化容量等于扩容门槛，<font color=blue>扩容门槛在构造方法里等于传入容量向上最近的2的n次方</font>，然后会乘以装载因子得到新的扩容门槛

> 例如初始化容量为 3 的时候，那就初始化的扩容门槛就是 4 ，即 2 的 2 次方
>
> - 第一次添加元素因为table是空的，所以会先调用一次 resize 方法，此时会将扩容门槛变成 3 ，即4*0.75
> - 当添加到第4个元素时，会进行扩容操作                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
>   - 首先当前的容量已经变成4了，那么扩容后变成了8，即两倍
>   - 然后扩容门槛也从3变成了6，即两倍

（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，**新扩容门槛为旧扩容门槛的2倍**（即原容量是16，扩容后变成32；旧门槛是12，扩容后是24）

（4）创建一个新容量的桶

（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置



#### 总结

（1）HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；

（2）HashMap的默认初始容量为16（1<<4），默认装载因子为0.75f，容量总是2的n次方；

（3）HashMap扩容时每次容量变为原来的两倍；

（4）当桶的数量小于64时不会进行树化，只会扩容；

（5）<font color=red>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化</font>

（6）当单个桶中元素数量小于6时，进行反树化；

（7）HashMap是非线程安全的容器；

（8）HashMap查找添加元素的时间复杂度都为O(1)



#### 红黑树特点

（1）节点是红色或黑色

（2）根节点是黑色

（3）每个叶节点（NIL节点，空节点）是黑色的

（4）每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）

（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

红黑树的时间复杂度为O(log n)，与树的高度成正比

红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等



#### 为什么数组长度要保证为2的幂次方

​		如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费（比如是4时，那么length-1=3，即0011；与操作后就不会浪费位置了）

​		如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大。更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费



## HashMap与HashTable的区别

1. HashMap是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的
2. HashMap允许 Key/Value 都为null；Hashtable的 Key/Value 都不允许为null
3. HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类



## HashMap在JDK7和8中有哪些不同

| 不同                     | JDK 1.7                                                      | JDK 1.8                                                      |
| :----------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 存储结构                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |
| 初始化方式               | 单独函数：`inflateTable()`                                   | 直接集成到了扩容函数`resize()`中                             |
| hash值计算方式           | 扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算                 | 扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算                 |
| 存放数据的规则           | 无冲突时，存放数组；冲突时，存放链表                         | 无冲突时，存放数组；冲突 & 链表长度 < 8：存放单链表；冲突 & 链表长度 > 8：树化并存放红黑树 |
| 插入数据方式             | 头插法（先讲原位置的数据移到后1位，再插入数据到该位置）      | 尾插法（直接插入到链表尾部/红黑树）                          |
| 扩容后存储位置的计算方式 | 全部按照原来方法进行计算（即hashCode ->> 扰动函数 ->> (h&length-1)） | 按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量） |



## ConcurrentHashMap的具体实现

### JDK7

ConcurrentHashMap采用 <font color=red>Segment + HashEntry</font> 的方式进行实现

![JDK7ConCurrentHashMap](images\91.JDK7ConCurrentHashMap.png)

1. 该类包含两个静态内部类 HashEntry 和 Segment 
   - HashEntry 用来封装映射表的键值对
   - Segment 用来充当锁的角色
2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，**必须首先获得对应的 Segment 锁**



### JDK8

采用 Node + CAS + Synchronized 来保证并发安全进行实现

![JDK8ConcurrentHashMap](images\91.JDK8ConcurrentHashMap.png)

